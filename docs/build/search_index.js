var documenterSearchIndex = {"docs":
[{"location":"core/build_phenome/#Build-Phenome","page":"Build Phenome","title":"Build Phenome","text":"","category":"section"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"build_phenome defines the phenomics information including QTL effects and heritability.","category":"page"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"Pages = [\"build_phenome.md\"]\nDepth = 4","category":"page"},{"location":"core/build_phenome/#Quick-Start","page":"Build Phenome","title":"Quick Start","text":"","category":"section"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"Quick setup by assigning number of QTL.","category":"page"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"build_phenome(n_qtls ::Union{Array{Int64, 1}, Int64};\n              args...)","category":"page"},{"location":"core/build_phenome/#Arguments","page":"Build Phenome","title":"Arguments","text":"","category":"section"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"n_qtls : Number of simulated QTLs. It can be an array of integers for multiple traits.\nvg : Genetic (co)variances of QTLs.\nh2 : Heritability of simulated traits. This will define the residual (co)variances.","category":"page"},{"location":"core/build_phenome/#Examples","page":"Build Phenome","title":"Examples","text":"","category":"section"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"Single trait","category":"page"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"julia> build_phenome(10)\n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 1\n[ Info: Heritability (h2)     : [0.5]\n┌ Info:\n│   Genetic_Variance =\n│    1×1 Array{Float64,2}:\n└     1.0\n┌ Info:\n│   Residual_Variance =\n│    1×1 Array{Float64,2}:\n└     1.0\n[ Info: Number of QTLs        : [10]","category":"page"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"Multi-trait with additional information","category":"page"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"julia> build_phenome([10, 15];\n                     vg = [1 .5\n                          .5  1],\n                     h2 = [.3, .8])\n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 2\n[ Info: Heritability (h2)     : [0.3, 0.8]\n┌ Info:\n│   Genetic_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.5\n└     0.5  1.0\n┌ Info:\n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     2.33333  0.0\n└     0.0      0.25\n[ Info: Number of QTLs        : [10 25]","category":"page"},{"location":"core/build_phenome/#Build-by-a-File-or-a-DataFrame","page":"Build Phenome","title":"Build by a File or a DataFrame","text":"","category":"section"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"Define genome by providing a formatted dataframe or a path to the file.","category":"page"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"build_phenome(dt        ::DataFrame; args...)\nbuild_phenome(filename  ::String;    args...)","category":"page"},{"location":"core/build_phenome/#Arguments-2","page":"Build Phenome","title":"Arguments","text":"","category":"section"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"dt : A DataFrame with required columns of eff_ prefixed specifying marker effects.\nfilename : A filepath to the file containing phenome information.","category":"page"},{"location":"core/build_phenome/#Example-of-the-DataFrame","page":"Build Phenome","title":"Example of the DataFrame","text":"","category":"section"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"4×7 DataFrame\n Row │ id      chr    bp       cM       MAF      eff_1    eff_2   \n     │ String  Int64  Int64    Float64  Float64  Float64  Float64 \n─────┼────────────────────────────────────────────────────────────\n   1 │ snp 1       1  1818249     50.8      0.5      0.1      0.0\n   2 │ snp 2       1  6557697     80.3      0.5      0.0     -0.3\n   3 │ snp_3       2  2298800     39.2      0.5      0.2      0.0\n   4 │ snp 4       2  5015698     66.3      0.5      0.0      0.5","category":"page"},{"location":"core/build_phenome/#Examples-2","page":"Build Phenome","title":"Examples","text":"","category":"section"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"By a filepath","category":"page"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"julia> build_phenome(\"path/map.csv\", h2 = [0.3, 0.5])","category":"page"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"or a dataframe","category":"page"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"julia> using DataFrames\njulia> data = CSV.read(\"path/map.csv\", DataFrame)\njulia> build_phenome(data, h2 = [0.3, 0.5])\n\n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 2\n[ Info: Heritability (h2)     : [0.3, 0.5]\n┌ Info: \n│   Genetic_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     2.33333  0.0\n└     0.0      1.0\n[ Info: Number of QTLs        : [2 2]","category":"page"},{"location":"core/build_phenome/#Build-by-QTL-Effects","page":"Build Phenome","title":"Build by QTL Effects","text":"","category":"section"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"build_phenome(QTL_effects ::Union{Array{Float64}, SparseMatrixCSC}; args...)","category":"page"},{"location":"core/build_phenome/#Arguments-3","page":"Build Phenome","title":"Arguments","text":"","category":"section"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"QTL_effects : A matrix storing marker effects with the dimension of individuals by markers.","category":"page"},{"location":"core/build_phenome/#Examples-3","page":"Build Phenome","title":"Examples","text":"","category":"section"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"julia> effects = [0.1  0.0\n                  0.0 -0.3\n                  0.2  0.0\n                  0.0  0.5]\njulia> build_phenome(effects)\n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 2\n[ Info: Heritability (h2)     : [0.5, 0.5]\n┌ Info: \n│   Genetic_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n[ Info: Number of QTLs        : [2 2]","category":"page"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"It's also possible to add additional information such as heritability.","category":"page"},{"location":"core/build_phenome/","page":"Build Phenome","title":"Build Phenome","text":"julia> build_phenome(effects, h2=[0.1, 0.8])\n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 2\n[ Info: Heritability (h2)     : [0.1, 0.8]\n┌ Info: \n│   Genetic_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     9.0  0.0\n└     0.0  0.25\n[ Info: Number of QTLs        : [2 2]","category":"page"},{"location":"lib/#Library","page":"Library ","title":"Library","text":"","category":"section"},{"location":"lib/#Index","page":"Library ","title":"Index","text":"","category":"section"},{"location":"lib/","page":"Library ","title":"Library ","text":"Pages = [\"lib.md\"]","category":"page"},{"location":"lib/#Contents","page":"Library ","title":"Contents","text":"","category":"section"},{"location":"lib/","page":"Library ","title":"Library ","text":"build_genome\nbuild_phenome\nCohort\nmate\nselect\nbreed\ngenetic_evaluation","category":"page"},{"location":"lib/#Main.XSim.build_genome","page":"Library ","title":"Main.XSim.build_genome","text":"Quick Start\n\nQuick setup by assigning number of markers and chromosomes.\n\nbuild_genome(;n_marker ::Int64=-1,\n              n_chr    ::Int64=10,\n              species  ::String=\"none\",\n              args...)\n\nArguments\n\nn_marker : Number of simulated markers for each chromosome\nn_chr: Number of simulated chromosome with length of 100 centimorgan\nspecies : Infer genetic position (Morgan) by pre-load linkage maps, available species are: [\"cattle\", and \"pig\"]\n\nExamples\n\njulia> build_genome(n_chr    = 2,\n                    n_marker = 10000)\n\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 2\n[ Info:\n[ Info: Chromosome Length (cM): 200.0\n[ Info: [100.0, 100.0]\n[ Info:\n[ Info: Number of Loci        : 20000\n[ Info: [10000, 10000]\n[ Info:\n[ Info: Genotyping Error      : 0.0\n[ Info: Mutation Rate         : 0.0\n[ Info:\n\nDefine genome by a file or a DataFrame\n\nDefine genome by providing a formatted dataframe or a path to the file.\n\nbuild_genome(dt      ::DataFrame;\n             species ::String=\"none\",\n             args...)\n\nbuild_genome(filename::String;\n             species ::String=\"none\",\n             args...)\n\nArguments\n\ndt : A DataFrame with required columns of chr and cM, or chr and bp if species is provided for the inference.\nfilename : A filepath to the file containing genome information.\nspecies : Adjust genetic position (Morgan) by pre-load linkage maps, available species are: [\"cattle\", and \"pig\"]\n\nExample of the DataFrame\n\n4×7 DataFrame\n Row │ id      chr    bp       cM       MAF      eff_1    eff_2\n     │ String  Int64  Int64    Float64  Float64  Float64  Float64\n─────┼────────────────────────────────────────────────────────────\n   1 │ snp_1       1  1818249     50.8      0.5      0.1      0.0\n   2 │ snp_2       1  6557697     80.3      0.5      0.0      0.0\n   3 │ snp_3       2  2298800     39.2      0.5      0.2      0.0\n   4 │ snp_4       2  5015698     66.3      0.5      0.0      0.5\n\nExamples\n\nBy a filepath\n\njulia> build_genome(\"path/map.csv\";\n                    rate_mutation=0.005, rate_error=0.01)\n\nor a dataframe\n\njulia> using DataFrames\njulia> data = CSV.read(\"path/map.csv\", DataFrame)\njulia> build_genome(data;\n                    rate_mutation=0.005, rate_error=0.01)\n\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 2\n[ Info:\n[ Info: Chromosome Length (cM): 146.6\n[ Info: [80.3, 66.3]\n[ Info:\n[ Info: Number of Loci        : 4\n[ Info: [2, 2]\n[ Info:\n[ Info: Genotyping Error      : 0.01\n[ Info: Mutation Rate         : 0.005\n[ Info:\n\nUse cattle genome as reference to infer the genetic positions\n\njulia> build_genome(\"path/map.csv\"; species=\"cattle\")\n\n[ Info: Arias,J.A. et al. (2009) A high density linkage map of the bovine genome. BMC Genetics, 10, 18.\n[ Info: Reference Genome : Btau 4.0\n[ Info: SNP Chip         : Affymetrix GeneChip Bovine Mapping 10K SNP kit\n\n┌ Warning: The provided genetic distances will be replaced with ones infered from preloaded linkage maps\n└ @ XSim ~/Dropbox/projects/XSim/src/objects/global.jl:118\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 2\n[ Info:\n[ Info: Chromosome Length (cM): 16.8\n[ Info: [15.1, 1.7]\n[ Info:\n[ Info: Number of Loci        : 4\n[ Info: [2, 2]\n[ Info:\n[ Info: Genotyping Error      : 0.0\n[ Info: Mutation Rate         : 0.0\n[ Info:\n\n\nExplict Definition\n\nDefine genome by providing genetic information of each loci explicitly.\n\nbuild_genome(chromosome    ::Array{Int64,   1},\n             bp            ::Array{Int64,   1},\n             cM            ::Array{Float64, 1},\n             maf           ::Array{Float64, 1};\n             rate_mutation ::Float64=0.0,\n             rate_error    ::Float64=0.0)\n\nArguments\n\nchromosome : Chromosome codes\nbp : Physical positions\ncM : Genetic positions\nmaf : Minor allele frequencies\nrate_mutation : Mutation rate\nrate_error : Error rate of genotyping\n\nExamples\n\njulia> ch  = [1,    1,     2,    2,    2]\njulia> bp  = [130,  205,   186,  503,  780]\njulia> cM  = [85.7, 149.1, 37.4, 83.6, 134.3]\njulia> maf = [0.5,  0.5,   0.5,  0.5,  0.5]\njulia> build_genome(ch, bp, cM, maf)\n\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 2\n[ Info:\n[ Info: Chromosome Length (cM): 283.4\n[ Info: [149.1, 134.3]\n[ Info:\n[ Info: Number of Loci        : 5\n[ Info: [2, 3]\n[ Info:\n[ Info: Genotyping Error      : 0.0\n[ Info: Mutation Rate         : 0.0\n[ Info:\n\n\n\n\n\n","category":"function"},{"location":"lib/#Main.XSim.build_phenome","page":"Library ","title":"Main.XSim.build_phenome","text":"Quick Start\n\nQuick setup by assigning number of QTL.\n\nbuild_phenome(n_qtls ::Union{Array{Int64, 1}, Int64};\n              args...)\n\nArguments\n\nn_qtls : Number of simulated QTLs. It can be an array of integers for multiple traits.\nvg : Genetic (co)variances of QTLs.\nh2 : Heritability of simulated traits. This will define the residual (co)variances.\n\nExamples\n\nSingle trait\n\njulia> build_phenome(10)\n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 1\n[ Info: Heritability (h2)     : [0.5]\n┌ Info:\n│   Genetic_Variance =\n│    1×1 Array{Float64,2}:\n└     1.0\n┌ Info:\n│   Residual_Variance =\n│    1×1 Array{Float64,2}:\n└     1.0\n[ Info: Number of QTLs        : [10]\n\nMulti-trait with additional information\n\njulia> build_phenome([10, 15];\n                     vg = [1 .5\n                          .5  1],\n                     h2 = [.3, .8])\n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 2\n[ Info: Heritability (h2)     : [0.3, 0.8]\n┌ Info:\n│   Genetic_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.5\n└     0.5  1.0\n┌ Info:\n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     2.33333  0.0\n└     0.0      0.25\n[ Info: Number of QTLs        : [10 25]\n\n────────────────────────────────────────────────────────────────\n\nDefine phenome by a file or a DataFrame\n\nDefine genome by providing a formatted dataframe or a path to the file.\n\nbuild_phenome(dt        ::DataFrame; args...)\nbuild_phenome(filename  ::String;    args...)\n\nArguments\n\ndt : A DataFrame with required columns of eff_ prefixed specifying marker effects.\nfilename : A filepath to the file containing phenome information.\n\nExample of the DataFrame\n\n4×7 DataFrame\n Row │ id      chr    bp       cM       MAF      eff_1    eff_2   \n     │ String  Int64  Int64    Float64  Float64  Float64  Float64 \n─────┼────────────────────────────────────────────────────────────\n   1 │ snp 1       1  1818249     50.8      0.5      0.1      0.0\n   2 │ snp 2       1  6557697     80.3      0.5      0.0     -0.3\n   3 │ snp_3       2  2298800     39.2      0.5      0.2      0.0\n   4 │ snp 4       2  5015698     66.3      0.5      0.0      0.5\n\nExamples\n\nBy a filepath\n\njulia> build_phenome(\"path/map.csv\", h2 = [0.3, 0.5])\n\nor a dataframe\n\njulia> using DataFrames\njulia> data = CSV.read(\"path/map.csv\", DataFrame)\njulia> build_phenome(data, h2 = [0.3, 0.5])\n\n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 2\n[ Info: Heritability (h2)     : [0.3, 0.5]\n┌ Info: \n│   Genetic_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     2.33333  0.0\n└     0.0      1.0\n[ Info: Number of QTLs        : [2 2]\n\n────────────────────────────────────────────────────────────────\n\nDefine phenome by a matrix of QTL effects\n\nbuild_phenome(QTL_effects ::Union{Array{Float64}, SparseMatrixCSC}; args...)\n\nArguments\n\nQTL_effects : A matrix storing marker effects with the dimension of individuals by markers.\n\nExamples\n\njulia> effects = [0.1  0.0\n                  0.0 -0.3\n                  0.2  0.0\n                  0.0  0.5]\njulia> build_phenome(effects)\n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 2\n[ Info: Heritability (h2)     : [0.5, 0.5]\n┌ Info: \n│   Genetic_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n[ Info: Number of QTLs        : [2 2]\n\nIt's also possible to add additional information such as heritability.\n\njulia> build_phenome(effects, h2=[0.1, 0.8])\n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 2\n[ Info: Heritability (h2)     : [0.1, 0.8]\n┌ Info: \n│   Genetic_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     9.0  0.0\n└     0.0  0.25\n[ Info: Number of QTLs        : [2 2]\n\n\n\n\n\n","category":"function"},{"location":"lib/#Main.XSim.Cohort","page":"Library ","title":"Main.XSim.Cohort","text":"Initialize a cohort by population size\n\nCohort(n::Int64=0)\n\nArguments\n\nn : An integer to assign the population size.\n\nExamples\n\njulia> cohort = Cohort(5)\n[ Info: Cohort (5 individuals)\n[ Info:\n[ Info: Mean of breeding values:\n[ Info: [1.265 1.697]\n[ Info:\n[ Info: Variance of breeding values:\n[ Info: [1.6 1.4]\n\n──────────────────────────────────────────────────────────────\n\nInitialize a cohort by genotypes/haplotypes files\n\nCohort(genetic_data ::Union{DataFrame, Array{Int64}}; args...)\nCohort(filename     ::String; args...)\n\nArguments\n\ngenetic_data : A dataframe/2D-array that stores genotypes/haplotypes in the dimension of individuals by markers.\nfilename : A filepath to a file storing genotypes/haplotypes data.\nn : Number of lines to be loaded from the file. The default value is -1 and the entire file will be loaded.\nrandom : By default it's set to true to randomly select n lines (individuals) from the file to generate the cohort.\nalter_maf : It will update MAF based on the provided genotypes if it's set to true (default).\n\nExample of the demo_genotypes.csv and demo_haplotypes.csv\n\nBoth demo files store marker information for 5 individuals and 4 markers. Use DATA(\"demo_genotypes.csv\") to interact with demo files.\n\n# demo_genotypes.csv\n# rows: individuals, columns: markers\n# Homozygote is coded as 0 and 2, otherwise is coded as 1\n2,0,0,1\n0,0,1,0\n0,1,0,2\n1,1,0,2\n2,0,2,0\n\n# demo_haplotypes.csv\n# rows: individuals, columns: alleles\n# Reference allele is coded as 0, otherwise is coded as 1\n1,1,0,0,0,0,1,0\n0,0,0,0,1,0,0,0\n0,0,0,1,0,0,1,1\n1,0,1,0,0,0,1,1\n1,1,0,0,1,1,0,0\n\nExample\n\n# Load entire file\njulia> cohort = Cohort(\"demo_haplotypes.csv\")\njulia> get_genotypes(cohort)\n5×4 Array{Int64,2}:\n 2  0  0  1\n 2  0  2  0\n 0  0  1  0\n 1  1  0  2\n 0  1  0  2\n\n# Randomly load 3 individuals with a dataframe.\njulia> data = DATA(\"demo_haplotypes.csv\", header=false)\njulia> cohort = Cohort(data, random=true, n=3)\njulia> get_genotypes(cohort)\n3×4 Array{Int64,2}:\n 2  0  2  0\n 0  1  0  2\n 1  1  0  2\n\n# Replace marker MAF by the provided file\njulia> cohort = Cohort(\"demo_haplotypes.csv\", alter_maf=true)\n[ Info: MAF has been updated based on provided haplotypes/genotypes\n[ Info: Cohort (5 individuals)\n[ Info:\n[ Info: Mean of breeding values:\n[ Info: [1.418]\n[ Info:\n[ Info: Variance of breeding values:\n[ Info: [2.012]\n\n──────────────────────────────────────────────────────────────\n\nFunctions that insepct Cohort properties:\n\nAll the listed functions can take a keyword argument ID=true to insert individuals' IDs as the first column.\n\nGenotypes\n\nGenotype matirx in the dimension of individuals by markers\n\njulia> get_genotypes(cohort)\n5×4 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}:\n 0  0  1  0\n 2  0  2  0\n 2  0  0  1\n 0  1  0  2\n 1  1  0  2\n\nQTLs\n\nQTLs matirx in the dimension of individuals by markers\n\njulia> get_QTLs(cohort)\n5×3 Array{Int64,2}:\n 2  2  0\n 0  0  2\n 0  1  0\n 1  0  2\n 2  0  1\n\nBreeding values\n\nBreeding values in the dimenstion individuals by traits\n\njulia> get_BVs(cohort)\n5×2 LinearAlgebra.Adjoint{Float64,Array{Float64,2}}:\n 1.26491   0.0\n 3.79473   0.0\n 1.26491   1.21268\n 0.0       1.69775\n 0.632456  1.69775\n\nPedigree\n\nPedigree matrix, listed columns are in the order of individuals' ID, sire ID, and dam ID.\n\njulia> get_pedigree(cohort)\n5×3 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}:\n1  0  0\n2  0  0\n3  0  0\n4  0  0\n5  0  0\n\nMinor Allele Frequencies (MAF)\n\nIn the case where we have 3 QTLs out of 4 markers, we want to compare their allel frequencies.\n\njulia> get_MAF(cohort)\n4-element Array{Float64,1}:\n 0.5\n 0.2\n 0.3\n 0.5\n\nPhenotypes\n\nSimulate cohort phenotypes based on the defined phenome. h2 and ve can be assigned specifically for this one-time simulation.\n\njulia> get_phenotypes(cohort)\n5×1 Array{Float64,2}:\n  1.1126064336992942\n -0.8337021175232547\n -0.363621019381922\n  4.042256656472762\n  1.7828800511223049\n\n\n\n\n\n","category":"type"},{"location":"lib/#Main.XSim.mate","page":"Library ","title":"Main.XSim.mate","text":"Mating function\n\nmate(cohort_A         ::Cohort,\n     cohort_B         ::Cohort;\n     nA               ::Int64=cohort_A.n,\n     nB_per_A         ::Int64=1,\n     n_per_mate       ::Int64=1,\n     replace_A        ::Bool =false,\n     replace_B        ::Bool =false,\n     ratio_malefemale ::Union{Float64, Int64}=0,\n     scheme           ::String =\"none\",\n     args...)\n\nmate(cohort::Cohort; args...) =  mate(cohort, cohort; args...)\n\nArguments\n\nPositional arguments\n\ncohort_A : A cohort object that is treated as common mating parents.\ncohort_B : A cohort object that is a mating pool from which individuals are sampled to mate with cohort_A.\n\nKeyword arguments\n\nnA : nA individuals will be sampled from cohort_A and treated as common parents.\nnB_per_A : nB_per_A individuals sampled from cohort_B will mate with each individual from cohort_A.\nn_per_mate : n_per_mate progenies will be reproduced from each pair of mating parent.\nreplace_A : Whether the sampling is replacable in cohort_A.\nreplace_B : Whether the sampling is replacable in cohort_B.\nratio_malefemale : By default, two cohorts which are male and female progenies will be returned. ratio_malefemale defined the progenies ratio of males over females. If ratio_malefemale=0, only one cohort will be returned.\nscheme : Available options are [\"random\", \"diallel cross\", \"selfing\", \"DH\"]. See the examples for more details.\n\nOutputs\n\nBy default, two cohort objects will be returned. The first cohort is assumed to be male progenies and the other cohort are female progenies. The size of two cohorts will folow the ratio raiot_malefemale. When ratio_malefemale is set to 0, only one cohort will be returned.\n\nExample\n\nRandom mating (Default)\n\nInitialize cohorts\n\njulia> cohort_A = Cohort(5)\njulia> cohort_B = Cohort(10)\n\nDefine mating events\n\njulia> args = Dict(:nA               => cohort_A.n,\n                   :nB_per_A         => 1,\n                   :replace_A        => false,\n                   :replace_B        => false,\n                   :n_per_mate       => 1)\njulia> progenies = mate(cohort_A, cohort_B; args...)\n\n# Equivalent\njulia> progenies = mate(cohort_A, cohort_B)\n\n# Equivalent\njulia> progenies = mate(cohort_A, cohort_B; scheme=\"random\")\n\n# Equivalent\njulia> progenies = cohort_A * cohort_B\n\nCheck the pedigree to see if the mating goes as desired.\n\njulia> get_pedigree(progenies)\n5×3 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}:\n 19  1   8\n 16  2   6\n 17  3  10\n 20  4  15\n 18  5  14\n\nDiallel cross\n\nInitialize cohorts\n\njulia> cohort_A = Cohort(2)\njulia> cohort_B = Cohort(5)\n\nDefine mating events\n\njulia> args = Dict(:nA              => sires.n,\n                   :nB_per_A        => dams.n,\n                   :replace_A       => false,\n                   :replace_B       => false,\n                   :n_per_mate      => 1,\n                   :ratio_malefemale=> 1)\njulia> male, female = mate(cohort_A, cohort_B; args...)\n\n# Equivalent\njulia> male, female = mate(cohort_A, cohort_B; scheme=\"diallel cross\")\n\nCheck the pedigree to see if the mating goes as desired.\n\njulia> get_pedigree(male + female)\n10×3 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}:\n 12  2  7\n 10  2  6\n 11  2  4\n 14  1  3\n 15  1  5\n  9  2  5\n 13  1  6\n 17  1  4\n  8  2  3\n 16  1  7\n\nSelfing\n\nInitialize cohorts\n\njulia> parents = Cohort(5)\n\nIn the selfing scheme, only one cohort is required.\n\njulia> args = Dict(:nA          => 3,\n                   :replace_A   => false,\n                   :n_per_mate  => 5,\n                   :scheme      => \"selfing\")\njulia> progenies = mate(parents; args...)\n\nInspect the pedigree to verify the mating behavior\n\njulia> get_pedigree(progenies)\n15×3 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}:\n  6  4  4\n  7  4  4\n  8  4  4\n  9  4  4\n 10  4  4\n 11  1  1\n 12  1  1\n 13  1  1\n 14  1  1\n 15  1  1\n 16  5  5\n 17  5  5\n 18  5  5\n 19  5  5\n 20  5  5\n\n\n\n\n\n","category":"function"},{"location":"lib/#Main.XSim.select","page":"Library ","title":"Main.XSim.select","text":"Selection function\n\nselect(cohort      ::Cohort,\n       n           ::Int64,\n       criteria    ::Union{String, Array} = \"phenotypes\";\n       h2          ::Union{Array{Float64}, Float64}=GLOBAL(\"h2\"),\n       ve          ::Union{Array{Float64}, Float64}=GLOBAL(\"Ve\"),\n       weights     ::Array{Float64, 1}  =[1.0],\n       return_log  ::Bool               =false,\n       is_random   ::Bool               =false,\n       silent      ::Bool               =GLOBAL(\"silent\")\n\nselect(cohort::Cohort, ratio::Float64; args...)\n\nArguments\n\nPositional arguments\n\ncohort : A cohort from which individuals are selected.\nn : n individuals are selected.\nratio : ratio portion of individuals are selected.\ncriteria : Criteria that will be used for the selecition. Default \"phenotypes\", the options are [\"phenotypes\", \"GBLUP\", array]. If set to \"GBLUP\",  a genetic evaluation is carried out by JWAS and the estimated breeding values will be the criteria. It's also avaialbe to provdie the criteria (e.g., phenotypes matrix) directly for the selection.\n\nKeyword arguments\n\nh2 : The heritability h2 of the simulated phenotypes.\nve : The residual covariance ve of the simulated phenotypes.\nweight : Linear coefficients of traits for the selection. The selection is more sensitive to traits with greater weight. Negative\nreturn_log : Default false. Set true to return selection differential and selection response besides the selected cohort.\nsilent : Default false. Set true to mute the log messages.\n\nOutputs\n\nA selected cohort object will be returned. If return_log is set to true, a dictionary object containing the selected cohort, selection differential, and selection response will be returned.\n\n─────────────────────────────────────────────────────────\n\nExample\n\nSingle Trait Selection\n\nSet demo genome and phenome with single traits controlled by 50 QTLs.\n\njulia> build_demo()\njulia> build_phenome(50)\njulia> summary()\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 10\n[ Info: \n[ Info: Chromosome Length (cM): 1500.0\n[ Info: [150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0]\n[ Info: \n[ Info: Number of Loci        : 1000\n[ Info: [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]\n[ Info: \n[ Info: Genotyping Error      : 0.0\n[ Info: Mutation Rate         : 0.0\n[ Info: \n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 1\n[ Info: Heritability (h2)     : [0.5]\n┌ Info: \n│   Genetic_Variance =\n│    1×1 Array{Float64,2}:\n└     1.0\n┌ Info: \n│   Residual_Variance =\n│    1×1 Array{Float64,2}:\n└     1.0\n[ Info: Number of QTLs        : [50]\n\nInitialize a cohort with 100 individuals\n\njulia> cohort = Cohort(100)\n\nSelect 30 individuals\n\n# Select top 30 individuals\njulia> cohort_s = select(cohort, 30)\n# Equivalent\njulia> cohort_s = select(cohort, 0.3)\n\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [1.174]\n[ Info: Selection response     (G): [0.843]\n┌ Info:\n│   Residual_Variance =\n│    1×1 Array{Float64,2}:\n└     1.0\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info:\n[ Info: Mean of breeding values:\n[ Info: [1.448]\n[ Info:\n[ Info: Variance of breeding values:\n[ Info: [0.367]\n\nAssign Heritability h2 or Residual Covariance ve\n\n# Assign heritability\njulia> progenies = select(cohort, 30, h2=0.1)\n\n# Equivalent in the case where genetic variance `vg` is 1.0\njulia> progenies = select(cohort, 30, ve=9.0)\n\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [1.182]\n[ Info: Selection response     (G): [0.338]\n┌ Info:\n│   Residual_Variance =\n│    1×1 Array{Float64,2}:\n└     9.0\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [0.956]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.643]\n\nNegative Selection\n\nSet is_positive=false to rank individuals in ascending order\n\njulia> progenies = select(cohort, 30, is_positive=false)\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [-1.19]\n[ Info: Selection response     (G): [-0.89]\n┌ Info: \n│   Residual_Variance =\n│    1×1 Array{Float64,2}:\n└     1.0\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [-0.24]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.566]\n\nRandom Selection\n\njulia> progenies = select(cohort, 30, is_random=true)\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [-0.06]\n[ Info: Selection response     (G): [-0.191]\n┌ Info: \n│   Residual_Variance =\n│    1×1 Array{Float64,2}:\n└     1.0\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [0.441]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.946]\n\nSelection wiht Multiple Parameters\n\nIt's possible specify multiple parameters described above in one selection. User can either enclose parameters as keyword arguments, or pass them through a dictionary object.\n\n# Keyword args\njulia> progenies = select(cohort, 30, h2=0.3, is_positive=false)\n\n# Equivalent\njulia> args = Dict(:h2=>0.3,\n                   :is_positive=>false)\njulia> progenies = select(cohort, 30; args...)\n\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [-1.086]\n[ Info: Selection response     (G): [-0.486]\n┌ Info: \n│   Residual_Variance =\n│    1×1 Array{Float64,2}:\n└     2.3333333333333335\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [0.154]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.818]\n\n─────────────────────────────────────────────────────────\n\nMulti-Trait Selection\n\nSet demo genome and phenome with single traits controlled by 50 QTLs.\n\njulia> build_demo()\njulia> summary()\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 10\n[ Info: \n[ Info: Chromosome Length (cM): 1500.0\n[ Info: [150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0]\n[ Info: \n[ Info: Number of Loci        : 1000\n[ Info: [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]\n[ Info: \n[ Info: Genotyping Error      : 0.0\n[ Info: Mutation Rate         : 0.0\n[ Info: \n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 2\n[ Info: Heritability (h2)     : [0.5, 0.5]\n┌ Info: \n│   Genetic_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n[ Info: Number of QTLs        : [3 8]\n\nInitialize a cohort with 100 individuals\n\njulia> cohort = Cohort(100)\n\nAssign Heritabilities for Multiple Traits\n\njulia> progenies = select(cohort, 30, h2=[0.9, 0.3])\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [0.468 1.028]\n[ Info: Selection response     (G): [0.383 0.636]\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     0.111111  0.0\n└     0.0       2.33333\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [-0.889 0.28]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.947 0.625]\n\nAssign Trait Correlations via Residual Covariance\n\njulia> progenies = select(cohort, 30, ve=[1   0.3\n                                          0.3   1])\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [0.866 0.925]\n[ Info: Selection response     (G): [0.662 0.762]\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.3\n└     0.3  1.0\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [-0.608 0.406]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.549 0.476]\n\nDerive Selection Index for Multiple Traits\n\nAssigning a vector to the parameter weights to derive a selection index which is a linear combintation of the weights and the phenotypes.  In this example, we demonstrate two traits with the heritability of 0.3 and 0.8, respectively. And we can select traits with more weight on the second trait which is more heritable, and negatively select the first trait.\n\njulia> progenies = select(cohort, 30, h2=[.3, .8], weights=[-0.1, 0.9])\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [-0.318 1.027]\n[ Info: Selection response     (G): [-0.233 0.869]\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     2.33333  0.0\n└     0.0      0.25\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [-1.508 0.513]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [1.053 0.458]\n\n\n\n\n\n","category":"function"},{"location":"lib/#Main.XSim.breed","page":"Library ","title":"Main.XSim.breed","text":"Wrap-up function: breed()\n\nbreed(cohort_A         ::Cohort,\n      cohort_B         ::Cohort;\n      n_gens           ::Int64=1,\n      n_select         ::Int64=cohort_A.n + cohort_B.n,\n      n_select_males   ::Int64=cohort_A.n,\n      n_select_females ::Int64=cohort_B.n,\n      select_all_gens  ::Bool=false,\n      args...)\n\nbreed(cohort::Cohort, n_gens::Int64, args...) =\n    breed(cohort, cohort, n_gens; args...)\n\nArguments\n\nPositional arguments\n\ncohort_A : A cohort object that is treated as common mating parents. It's asssumed to be sires/males parents.\ncohort_B : A cohort object that is a mating pool from which individuals are sampled to mate with cohort_A. It's assumed to be dams/female parents.\n\nKeywords arguments\n\nn_gens : An integer specifying how many mate-select generations are carried out.\nn_select : Used when ratio_malefemale is set to 0. n_select individuals are selected as parents for the next generation.\nn_select_males : Used when ratio_malefemale is not 0. n_select_males will be selected as male parents for the next generation.\nn_select_females : Used when ratio_malefemale is not 0. n_select_females will be selected as female parents for the next generation.\nselect_all_gens : Default \"false\" and parents are not included in the next generation pool for selections. Set select_all_gens to \"true\" if the selections consider individuals from all generations.\n\nOutputs\n\nBy default, two cohort objects will be returned. The first cohort is assumed to be male progenies and the other cohort are female progenies. The size of two cohorts will folow the ratio raiot_malefemale. When ratio_malefemale is set to 0, only one cohort will be returned.\n\nExamples\n\nWe can have 10 sires and mate each sire with 5 dams for 5 generations. In each generation, we randomly select 10 male progenies as sires and all female progenies as dams for the next generation. We can derive such breeding scheme as below:\n\njulia> args  = Dict(# mating arguments\n                    :nA               => 10,\n                    :nB_per_A         => 5,\n                    :n_per_mate       => 2,\n                    :ratio_malefemale => 1.0,\n                    # selection arguments\n                    :is_random        => true,\n                    # breeding arguments\n                    :n_gens           => 5,\n                    :nA_select        => 10,\n                    :select_all_gens  => true)\n\nSimulate 10 sires and 50 dams as founders.\n\njulia> sires = Founders(10)\njulia> dams  = Founders(50)\n\nBreed cohorts based on the defined arguments.\n\njulia> sires, dams = breed(sires, dams; args...)\n[ Info: Gen 0 -> Mean of BVs: [1.665 2.745], Variance of BVs: [1.008 0.479]\n[ Info: Gen 1 -> Mean of BVs: [1.719 2.715], Variance of BVs: [0.96 0.546]\n[ Info: Gen 2 -> Mean of BVs: [1.754 2.777], Variance of BVs: [0.936 0.724]\n[ Info: Gen 3 -> Mean of BVs: [1.766 2.796], Variance of BVs: [0.927 0.775]\n[ Info: Gen 4 -> Mean of BVs: [1.773 2.771], Variance of BVs: [0.951 0.781]\n[ Info: Gen 5 -> Mean of BVs: [1.813 2.751], Variance of BVs: [0.952 0.804]\n([ Info: Cohort (60 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [1.855 2.593]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.884 0.697]\n, [ Info: Cohort (300 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [1.805 2.782]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.969 0.822]\n\nThe result is equivalent to the following mate-select iterations:\n\njulia> for _ in 1:5\n            males, females = mate(sires, dams, args...)\n            sires         += select(males, n_sires, args...)\n            dams          += females\n       end\n\n\n\n\n\n","category":"function"},{"location":"lib/#Main.XSim.genetic_evaluation","page":"Library ","title":"Main.XSim.genetic_evaluation","text":"Genetic evaluation\n\ngenetic_evaluation(cohort         ::Cohort,\n                   phenotypes     ::DataFrame=DataFrame();\n                   model_equation ::String=\"\",\n                   covariates     ::String=\"\",\n                   random_iid     ::String=\"\",\n                   random_str     ::String=\"\",\n                   methods        ::String=\"GBLUP\",\n                   add_genotypes  ::Bool=true,\n                   idx_missing_p  ::Any=[],\n                   return_out     ::Bool=false,\n                   args...)\n\nArguments\n\ncohort : The evaluated cohort.\nphenotypes : A dataframe wiht columns of id, traits, and other studied factors.\nh2 : Default 0.5. Heritability for simulating cohort phenotypes if no phenotype is provided.\nve : Default 1. Residual variance for simulating cohort phenotypes if no phenotype is provided.\nmodel_equation : Default \"y ~ intercept\". The equation for fitting the breeding values.\ncovariates : Specifies terms in phenotypes as continuous factors. Must be included in model_equation as well.\nrandom_iid : Specifies terms in phenotypes as random effects (i.i.d.). Must be included in model_equation as well.\nrandom_str : Specifies terms in phenotypes as random effects (pedigree). Must be included in model_equation as well.\nmethods : Default \"GBLUP\". Defines what models/methods used in the genetic evaluation.\nadd_genotypes : Default true. Genotypes will be included in the equation.\nidx_missing_p : A vector assigning which individuals are not phenotyped.\nreturn_out : Default false. Set to true to return the complete JWAS outputs.\n\nOutputs\n\nA n by t matrix containing breeding values will be return if return_out = false, where n is number of individuals and t is number of evaluated traits. A complete JWAS outputs will be returned if return_out = true.\n\nExample of the phenotypes dataframe\n\n Row │ ID           y1              y2               factor_1  factor_2\n     │ String       Float64?        Float64?         Int64     Int64\n─────┼─────────────────────────────────────────────────────────────\n   1 │ 1             0.88976        -0.0798048         1         1\n   2 │ 2            -0.783203        0.988616          1         1\n   3 │ 3             missing         missing           1         1\n   4 │ 4             missing         missing           1         1\n   5 │ 5             missing         missing           1         1\n   6 │ 6             missing         missing           1         2\n   7 │ 7             missing         missing           1         2\n   8 │ 8            -1.76058         0.277289          1         2\n   9 │ 9             0.938871        2.57784           1         2\n  10 │ 10            0.37026         3.15993           1         2\n  11 │ 11           -1.91869         0.0935064         2         3\n  12 │ 12           -0.89847         1.8987            2         3\n  13 │ 13            1.69663        -0.949513          2         3\n  14 │ 14            3.48862         0.654378          2         3\n  15 │ 15            1.39615         1.80355           2         3\n  16 │ 16            2.31685         2.13446           2         4\n  17 │ 17           -3.81017         0.0186156         2         4\n  18 │ 18           -1.71216        -0.0976809         2         4\n  19 │ 19            1.80917         1.34104           2         4\n  20 │ 20           -0.504771        3.22665           2         4\n\nExamples\n\nWe will use demo genome and phenome for the example. A cohort with 20 individuals is simulated.\n\njulia> build_demo()\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 10\n[ Info: \n[ Info: Chromosome Length (cM):\n[ Info: [150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0]\n[ Info: \n[ Info: Number of Loci        : 1000\n[ Info: [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]\n[ Info: \n[ Info: Genotyping Error      : 0.0\n[ Info: Mutation Rate         : 0.0\n[ Info: \n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 2\n[ Info: Heritability (h2)     : [0.5, 0.5]\n┌ Info: \n│   Genetic_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n[ Info: Number of QTLs        : [3 8]\n\njulia> cohort = Cohort(20)\n[ Info: Cohort (20 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [-0.862 -0.913]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.814 1.448]\n\n─────────────────────────────────────────────────────────\n\nBasic usage\n\nBy default, GBLUP will be performed without providing any argument.\n\njulia> out = genetic_evaluation(cohort)\n20×2 Array{Float64,2}:\n  42.2908     -5.89224\n   6.38041    -4.5895\n  19.5065    -57.4513\n  24.05      -84.5086\n  11.5925     45.5247\n -11.5926     -1.91879\n -29.2152    -35.5977\n  -1.92563    63.8841\n  19.8686     76.2722\n  22.6728     45.5179\n -58.2754     42.5953\n  28.556     -21.0314\n  11.5918     25.1126\n  -0.517653   -0.237724\n -11.4712    -47.3073\n -10.9575     -3.58754\n -11.7835     -9.62802\n -17.7895    -22.0821\n -39.5114     -3.46026\n   6.53008    -1.61416\n\nThe breeding values out can be used as criteria for the selection directly.\n\njulia> select(cohort, 5, out)\n[ Info: --------- Selection Summary ---------\n[ Info: Select 5 individuals out of 20 individuals\n[ Info: Selection differential (P): [0.783 1.192]\n[ Info: Selection response     (G): [0.344 1.063]\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (5 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [-0.552 0.367]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.181 0.539]\n\nConditions of the evaluation can be further defined by h2 or ve.\n\njulia> out = genetic_evaluation(cohort, ve = [1  0.5\n                                             0.5  1])\n\nSet return_out = true to obtain the complete JWAS outputs.\n\njulia> out = genetic_evaluation(cohort, return_out = true)\nDict{Any,Any} with 7 entries:\n  \"EBV_y2\"              => 20×3 DataFrame…\n  \"EBV_y1\"              => 20×3 DataFrame…\n  \"heritability\"        => 2×3 DataFrame…\n  \"location parameters\" => 2×5 DataFrame…\n  \"residual variance\"   => 4×3 DataFrame…\n  \"marker effects geno\" => 40×5 DataFrame…\n  \"genetic_variance\"    => 4×3 DataFrame…\n\n─────────────────────────────────────────────────────────\n\nCustomized phenotypes and factors.\n\nObtain JWAS-compatible dataframe. \n\ndt_p = get_phenotypes(cohort, \"JWAS\")\n\nAssign un-phenotyped individuals\n\njulia> idx = 3:6\njulia> allowmissing!(dt_p);\njulia> dt_p[idx, 2:end] .= missing;\njulia> first(dt_p, 10)\n10×3 DataFrame\n Row │ ID            y1               y2             \n     │ String?       Float64?         Float64?       \n─────┼──────────────────────────────────────────\n   1 │ 1             -0.0933375       -0.882781\n   2 │ 2             -1.50748         -2.12898\n   3 │ 3              missing          missing        \n   4 │ 4              missing          missing        \n   5 │ 5              missing          missing        \n   6 │ 6              missing          missing        \n   7 │ 7             -0.431361        -0.624666\n   8 │ 8             -1.17867          0.415607\n   9 │ 9              0.266733         1.02123\n  10 │ 10            -1.15588          0.737982\n\nProvide customized phenotypes for the evaluation\n\njulia> out = genetic_evaluation(dams, dt_p)\n\nIt's equivalent to set idx_missing_p = 3:6 for the missing phenotypes.\n\njulia> out = genetic_evaluation(dams, dt_p, idx_missing_p = 3:6)\nThe marker IDs are set to 1,2,...,#markers\nThe individual IDs is set to 1,2,...,#observations\nGenotype informatin:\n#markers: 1000; #individuals: 20\nThe folder results is created to save results.\nChecking genotypes...\nChecking phenotypes...\nIndividual IDs (strings) are provided in the first column of the phenotypic data.\nPhenotypes for 16 individuals are used in the analysis.These individual IDs are saved in the file IDs_for_individuals_with_phenotypes.txt.\n\nWe can simulated factor_1 and factor_2 as fixed and random effects, respectively. And we use both factor_1 and factor_2 to fit y1,  and factor_1 alone to fit y2.\n\njulia> dt_p[:, \"factor_1\"] = [i for i in 1:4 for j in 1:5];\njulia> dt_p[:, \"factor_2\"] = [i for i in 1:2 for j in 1:10];\njulia> out = genetic_evaluation(cohort, dt_p,\n                model_equation=\"y1 = intercept + factor_1 + factor_2\n                                y2 = intercept + factor_1\",\n                random_iid=\"factor_2\",\n                return_out=true)\n\nfactor_2 is not found in model equation 2.\nThe marker IDs are set to 1,2,...,#markers\nThe individual IDs is set to 1,2,...,#observations\nGenotype informatin:\n#markers: 1000; #individuals: 20\nThe folder results is created to save results.\nChecking genotypes...\nChecking phenotypes...\nIndividual IDs (strings) are provided in the first column of the phenotypic data.\nPhenotypes for 16 individuals are used in the analysis.These individual IDs are saved in the file IDs_for_individuals_with_phenotypes.txt.\nPrior information for random effect variance is not provided and is generated from the data.\n\nPi (Π) is not provided.\nPi (Π) is generated assuming all markers have effects on all traits.\n\nA Linear Mixed Model was build using model equations:\n\ny1 = intercept + factor_1 + factor_2\ny2 = intercept + factor_1\n\nModel Information:\n\nTerm            C/F          F/R            nLevels\nintercept       factor       fixed                1\nfactor_1        factor       fixed                4\nfactor_2        factor       random               2\n\nMCMC Information:\n\nchain_length                                    100\nburnin                                            0\nstarting_value                                 true\nprintout_frequency                              101\noutput_samples_frequency                          1\nconstraint                                    false\nmissing_phenotypes                             true\nupdate_priors_frequency                           0\nseed                                          false\n\nHyper-parameters Information:\n\nrandom effect variances (y1:factor_2):\n 0.45\nresidual variances:           \n 1.0f0  0.0f0\n 0.0f0  1.0f0\n\nGenomic Information:\n\ncomplete genomic data (i.e., non-single-step analysis)\n\nGenomic Category                               geno\nMethod                                        GBLUP\ngenetic variances (genomic):  \n 1.0  0.0\n 0.0  1.0\nestimateScale                                 false\n\nDegree of freedom for hyper-parameters:\n\nresidual variances:                           6.000\nrandom effect variances:                      5.000\nmarker effect variances:                      6.000\n\nThe version of Julia and Platform in use:\n\nJulia Version 1.5.4\nCommit 69fcb5745b (2021-03-11 19:13 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin18.7.0)\n  CPU: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-9.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_EDITOR = code\n  JULIA_NUM_THREADS = \n\nThe analysis has finished. Results are saved in the returned variable and text files. MCMC samples are saved in text files.\n\nDict{Any,Any} with 7 entries:\n  \"EBV_y2\"              => 20×3 DataFrame…\n  \"EBV_y1\"              => 20×3 DataFrame…\n  \"heritability\"        => 2×3 DataFrame…\n  \"location parameters\" => 12×5 DataFrame…\n  \"residual variance\"   => 4×3 DataFrame…\n  \"marker effects geno\" => 32×5 DataFrame…\n  \"genetic_variance\"    => 4×3 DataFrame…\n\n\n\n\n\n","category":"function"},{"location":"dev/custom_data/#Customized-Data","page":"Customized Data","title":"Customized Data","text":"","category":"section"},{"location":"core/GE/#Genetic-Evaluation","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"","category":"section"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Users can select individuals by random, phenotypes, or esti- mated breeding values from genetic evaluations. A genome-enabled analysis package JWAS (Cheng et al. 2018) has been already incorporated into XSimV2. Multiple methods can be per- formed in XSimV2 for genetic evaluations, including pedigree- based BLUP (Henderson 1984), GBLUP (Habier et al. 2007; Van- Raden 2008), Bayesian Alphabet (Meuwissen et al. 2001; Park and Casella 2008; Kizilkaya et al. 2010; Habier et al. 2011; Erbe et al. 2012; Moser et al. 2015; Gianola and Fernando 2020), and single-step methods (Legarra et al. 2009; Fernando et al. 2014) for both single-trait and multiple-trait analysis (Gianola and Fernando 2020).","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Pages = [\"GE.md\"]\nDepth = 4","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"genetic_evaluation(cohort         ::Cohort,\n                   phenotypes     ::DataFrame=DataFrame();\n                   model_equation ::String=\"\",\n                   covariates     ::String=\"\",\n                   random_iid     ::String=\"\",\n                   random_str     ::String=\"\",\n                   methods        ::String=\"GBLUP\",\n                   add_genotypes  ::Bool=true,\n                   idx_missing_p  ::Any=[],\n                   return_out     ::Bool=false,\n                   args...)","category":"page"},{"location":"core/GE/#Arguments","page":"Genetic Evaluation","title":"Arguments","text":"","category":"section"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"cohort : The evaluated cohort.\nphenotypes : A dataframe wiht columns of id, traits, and other studied factors.\nh2 : Default 0.5. Heritability for simulating cohort phenotypes if no phenotype is provided.\nve : Default 1. Residual variance for simulating cohort phenotypes if no phenotype is provided.\nmodel_equation : Default \"y ~ intercept\". The equation for fitting the breeding values.\ncovariates : Specifies terms in phenotypes as continuous factors. Must be included in model_equation as well.\nrandom_iid : Specifies terms in phenotypes as random effects (i.i.d.). Must be included in model_equation as well.\nrandom_str : Specifies terms in phenotypes as random effects (pedigree). Must be included in model_equation as well.\nmethods : Default \"GBLUP\". Defines what models/methods used in the genetic evaluation.\nadd_genotypes : Default true. Genotypes will be included in the equation.\nidx_missing_p : A vector assigning which individuals are not phenotyped.\nreturn_out : Default false. Set to true to return the complete JWAS outputs.","category":"page"},{"location":"core/GE/#Outputs","page":"Genetic Evaluation","title":"Outputs","text":"","category":"section"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"A n by t matrix containing breeding values will be return if return_out = false, where n is number of individuals and t is number of evaluated traits. A complete JWAS outputs will be returned if return_out = true.","category":"page"},{"location":"core/GE/#Example-of-the-phenotypes-dataframe","page":"Genetic Evaluation","title":"Example of the phenotypes dataframe","text":"","category":"section"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":" Row │ ID           y1              y2               factor_1  factor_2\n     │ String       Float64?        Float64?         Int64     Int64\n─────┼─────────────────────────────────────────────────────────────\n   1 │ 1             0.88976        -0.0798048         1         1\n   2 │ 2            -0.783203        0.988616          1         1\n   3 │ 3             missing         missing           1         1\n   4 │ 4             missing         missing           1         1\n   5 │ 5             missing         missing           1         1\n   6 │ 6             missing         missing           1         2\n   7 │ 7             missing         missing           1         2\n   8 │ 8            -1.76058         0.277289          1         2\n   9 │ 9             0.938871        2.57784           1         2\n  10 │ 10            0.37026         3.15993           1         2\n  11 │ 11           -1.91869         0.0935064         2         3\n  12 │ 12           -0.89847         1.8987            2         3\n  13 │ 13            1.69663        -0.949513          2         3\n  14 │ 14            3.48862         0.654378          2         3\n  15 │ 15            1.39615         1.80355           2         3\n  16 │ 16            2.31685         2.13446           2         4\n  17 │ 17           -3.81017         0.0186156         2         4\n  18 │ 18           -1.71216        -0.0976809         2         4\n  19 │ 19            1.80917         1.34104           2         4\n  20 │ 20           -0.504771        3.22665           2         4","category":"page"},{"location":"core/GE/#Examples","page":"Genetic Evaluation","title":"Examples","text":"","category":"section"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"We will use demo genome and phenome for the example. A cohort with 20 individuals is simulated.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"julia> build_demo()\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 10\n[ Info: \n[ Info: Chromosome Length (cM):\n[ Info: [150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0]\n[ Info: \n[ Info: Number of Loci        : 1000\n[ Info: [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]\n[ Info: \n[ Info: Genotyping Error      : 0.0\n[ Info: Mutation Rate         : 0.0\n[ Info: \n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 2\n[ Info: Heritability (h2)     : [0.5, 0.5]\n┌ Info: \n│   Genetic_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n[ Info: Number of QTLs        : [3 8]\n\njulia> cohort = Cohort(20)\n[ Info: Cohort (20 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [-0.862 -0.913]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.814 1.448]","category":"page"},{"location":"core/GE/#Basic-usage","page":"Genetic Evaluation","title":"Basic usage","text":"","category":"section"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"By default, GBLUP will be performed without providing any argument.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"julia> out = genetic_evaluation(cohort)\n20×2 Array{Float64,2}:\n  42.2908     -5.89224\n   6.38041    -4.5895\n  19.5065    -57.4513\n  24.05      -84.5086\n  11.5925     45.5247\n -11.5926     -1.91879\n -29.2152    -35.5977\n  -1.92563    63.8841\n  19.8686     76.2722\n  22.6728     45.5179\n -58.2754     42.5953\n  28.556     -21.0314\n  11.5918     25.1126\n  -0.517653   -0.237724\n -11.4712    -47.3073\n -10.9575     -3.58754\n -11.7835     -9.62802\n -17.7895    -22.0821\n -39.5114     -3.46026\n   6.53008    -1.61416","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"The breeding values out can be used as criteria for the selection directly.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"julia> select(cohort, 5, out)\n[ Info: --------- Selection Summary ---------\n[ Info: Select 5 individuals out of 20 individuals\n[ Info: Selection differential (P): [0.783 1.192]\n[ Info: Selection response     (G): [0.344 1.063]\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (5 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [-0.552 0.367]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.181 0.539]","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Conditions of the evaluation can be further defined by h2 or ve.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"julia> out = genetic_evaluation(cohort, ve = [1  0.5\n                                             0.5  1])","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Set return_out = true to obtain the complete JWAS outputs.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"julia> out = genetic_evaluation(cohort, return_out = true)\nDict{Any,Any} with 7 entries:\n  \"EBV_y2\"              => 20×3 DataFrame…\n  \"EBV_y1\"              => 20×3 DataFrame…\n  \"heritability\"        => 2×3 DataFrame…\n  \"location parameters\" => 2×5 DataFrame…\n  \"residual variance\"   => 4×3 DataFrame…\n  \"marker effects geno\" => 40×5 DataFrame…\n  \"genetic_variance\"    => 4×3 DataFrame…","category":"page"},{"location":"core/GE/#Customized-phenotypes-and-factors.","page":"Genetic Evaluation","title":"Customized phenotypes and factors.","text":"","category":"section"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Obtain JWAS-compatible dataframe. ","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"dt_p = get_phenotypes(cohort, \"JWAS\")","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Assign un-phenotyped individuals","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"julia> idx = 3:6\njulia> allowmissing!(dt_p);\njulia> dt_p[idx, 2:end] .= missing;\njulia> first(dt_p, 10)\n10×3 DataFrame\n Row │ ID            y1               y2             \n     │ String?       Float64?         Float64?       \n─────┼──────────────────────────────────────────\n   1 │ 1             -0.0933375       -0.882781\n   2 │ 2             -1.50748         -2.12898\n   3 │ 3              missing          missing        \n   4 │ 4              missing          missing        \n   5 │ 5              missing          missing        \n   6 │ 6              missing          missing        \n   7 │ 7             -0.431361        -0.624666\n   8 │ 8             -1.17867          0.415607\n   9 │ 9              0.266733         1.02123\n  10 │ 10            -1.15588          0.737982","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Provide customized phenotypes for the evaluation","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"julia> out = genetic_evaluation(dams, dt_p)","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"It's equivalent to set idx_missing_p = 3:6 for the missing phenotypes.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"julia> out = genetic_evaluation(dams, dt_p, idx_missing_p = 3:6)\nThe marker IDs are set to 1,2,...,#markers\nThe individual IDs is set to 1,2,...,#observations\nGenotype informatin:\n#markers: 1000; #individuals: 20\nThe folder results is created to save results.\nChecking genotypes...\nChecking phenotypes...\nIndividual IDs (strings) are provided in the first column of the phenotypic data.\nPhenotypes for 16 individuals are used in the analysis.These individual IDs are saved in the file IDs_for_individuals_with_phenotypes.txt.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"We can simulated factor_1 and factor_2 as fixed and random effects, respectively. And we use both factor_1 and factor_2 to fit y1,  and factor_1 alone to fit y2.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"julia> dt_p[:, \"factor_1\"] = [i for i in 1:4 for j in 1:5];\njulia> dt_p[:, \"factor_2\"] = [i for i in 1:2 for j in 1:10];\njulia> out = genetic_evaluation(cohort, dt_p,\n                model_equation=\"y1 = intercept + factor_1 + factor_2\n                                y2 = intercept + factor_1\",\n                random_iid=\"factor_2\",\n                return_out=true)\n\nfactor_2 is not found in model equation 2.\nThe marker IDs are set to 1,2,...,#markers\nThe individual IDs is set to 1,2,...,#observations\nGenotype informatin:\n#markers: 1000; #individuals: 20\nThe folder results is created to save results.\nChecking genotypes...\nChecking phenotypes...\nIndividual IDs (strings) are provided in the first column of the phenotypic data.\nPhenotypes for 16 individuals are used in the analysis.These individual IDs are saved in the file IDs_for_individuals_with_phenotypes.txt.\nPrior information for random effect variance is not provided and is generated from the data.\n\nPi (Π) is not provided.\nPi (Π) is generated assuming all markers have effects on all traits.\n\nA Linear Mixed Model was build using model equations:\n\ny1 = intercept + factor_1 + factor_2\ny2 = intercept + factor_1\n\nModel Information:\n\nTerm            C/F          F/R            nLevels\nintercept       factor       fixed                1\nfactor_1        factor       fixed                4\nfactor_2        factor       random               2\n\nMCMC Information:\n\nchain_length                                    100\nburnin                                            0\nstarting_value                                 true\nprintout_frequency                              101\noutput_samples_frequency                          1\nconstraint                                    false\nmissing_phenotypes                             true\nupdate_priors_frequency                           0\nseed                                          false\n\nHyper-parameters Information:\n\nrandom effect variances (y1:factor_2):\n 0.45\nresidual variances:           \n 1.0f0  0.0f0\n 0.0f0  1.0f0\n\nGenomic Information:\n\ncomplete genomic data (i.e., non-single-step analysis)\n\nGenomic Category                               geno\nMethod                                        GBLUP\ngenetic variances (genomic):  \n 1.0  0.0\n 0.0  1.0\nestimateScale                                 false\n\nDegree of freedom for hyper-parameters:\n\nresidual variances:                           6.000\nrandom effect variances:                      5.000\nmarker effect variances:                      6.000\n\nThe version of Julia and Platform in use:\n\nJulia Version 1.5.4\nCommit 69fcb5745b (2021-03-11 19:13 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin18.7.0)\n  CPU: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-9.0.1 (ORCJIT, skylake)\nEnvironment:\n  JULIA_EDITOR = code\n  JULIA_NUM_THREADS = \n\nThe analysis has finished. Results are saved in the returned variable and text files. MCMC samples are saved in text files.\n\nDict{Any,Any} with 7 entries:\n  \"EBV_y2\"              => 20×3 DataFrame…\n  \"EBV_y1\"              => 20×3 DataFrame…\n  \"heritability\"        => 2×3 DataFrame…\n  \"location parameters\" => 12×5 DataFrame…\n  \"residual variance\"   => 4×3 DataFrame…\n  \"marker effects geno\" => 32×5 DataFrame…\n  \"genetic_variance\"    => 4×3 DataFrame…","category":"page"},{"location":"core/GE/#References","page":"Genetic Evaluation","title":"References","text":"","category":"section"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Cheng, H., R. Fernando, and D. Garrick, 2018 JWAS: Julsi- taaimnoptlheemrentation of Whole-genome Analysis Soft- ware. Proceedings of the world congress on genetics applied to livestock production 11: 859.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Erbe, M., B. J. Hayes, L. K. Matukumalli, S. Goswami, P. J. Bow- man, et al., 2012 Improving accuracy of genomic predictions within and between dairy cattle breeds with imputed high- density single nucleotide polymorphism panels. Journal of Dairy Science 95: 4114–4129.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Fernando, R. L., J. C. Dekkers, and D. J. Garrick, 2014 A class of Bayesian methods to combine large numbers of genotyped and non-genotyped animals for whole-genome analyses. Ge- netics Selection Evolution 46: 50.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Gianola, D. and R. L. Fernando, 2020 A Multiple-Trait Bayesian Lasso for Genome-Enabled Analysis and Prediction of Com- plex Traits. Genetics 214: 305–331, Publisher: Genetics Section: Investigations.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Habier, D., R. L. Fernando, and J. C. M. Dekkers, 2007 The Im- pact of Genetic Relationship Information on Genome-Assisted Breeding Values. Genetics 177: 2389–2397, Publisher: Genetics Section: Investigations.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Habier, D., R. L. Fernando, K. Kizilkaya, and D. J. Garrick, 2011 Extension of the bayesian alphabet for genomic selection. BMC Bioinformatics 12: 186.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Henderson, C. R., 1984 Applications of linear models in animal breeding.. Publisher: University of Guelph.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Kizilkaya, K., R. L. Fernando, and D. J. Garrick, 2010 Genomic prediction of simulated multibreed and purebred performance using observed fifty thousand single nucleotide polymor- phism genotypes. Journal of Animal Science 88: 544–551.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Legarra, A., I. Aguilar, and I. Misztal, 2009 A relationship matrix including full pedigree and genomic information. Journal of Dairy Science 92: 4656–4663.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Meuwissen, T. H. E., B. J. Hayes, and M. E. Goddard, 2001 Pre- diction of Total Genetic Value Using Genome-Wide Dense Marker Maps. Genetics 157: 1819–1829, Publisher: Genetics Section: Investigations.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Moser, G., S. H. Lee, B. J. Hayes, M. E. Goddard, N. R. Wray, et al., 2015 Simultaneous Discovery, Estimation and Prediction Analysis of Complex Traits Using a Bayesian Mixture Model. PLOS Genetics 11: e1004969, Publisher: Public Library of Science.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"Park, T. and G. Casella, 2008 The Bayesian Lasso. Journal of the American Statistical Association 103: 681–686.","category":"page"},{"location":"core/GE/","page":"Genetic Evaluation","title":"Genetic Evaluation","text":"VanRaden, P. M., 2008 Efficient Methods to Compute Genomic Predictions. Journal of Dairy Science 91: 4414–4423.","category":"page"},{"location":"core/breed/#Breed:-Wrap-up-Function","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"","category":"section"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"Here, we introduce a function breed() as a wrapper for matings and selections. n_gens defines how many generations are simulated, and n_select_males or n_select_females determines how many male or female progenies are selected as sires or dams in the next generation.","category":"page"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"Pages = [\"breed.md\"]\nDepth = 4","category":"page"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"breed(cohort_A         ::Cohort,\n      cohort_B         ::Cohort;\n      n_gens           ::Int64=1,\n      n_select         ::Int64=cohort_A.n + cohort_B.n,\n      n_select_males   ::Int64=cohort_A.n,\n      n_select_females ::Int64=cohort_B.n,\n      select_all_gens  ::Bool=false,\n      args...)\n\nbreed(cohort::Cohort, n_gens::Int64, args...) =\n    breed(cohort, cohort, n_gens; args...)","category":"page"},{"location":"core/breed/#Arguments","page":"Breed: Wrap-up Function","title":"Arguments","text":"","category":"section"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"Positional arguments","category":"page"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"cohort_A : A cohort object that is treated as common mating parents. It's asssumed to be sires/males parents.\ncohort_B : A cohort object that is a mating pool from which individuals are sampled to mate with cohort_A. It's assumed to be dams/female parents.","category":"page"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"Keywords arguments","category":"page"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"n_gens : An integer specifying how many mate-select generations are carried out.\nn_select : Used when ratio_malefemale is set to 0. n_select individuals are selected as parents for the next generation.\nn_select_males : Used when ratio_malefemale is not 0. n_select_males will be selected as male parents for the next generation.\nn_select_females : Used when ratio_malefemale is not 0. n_select_females will be selected as female parents for the next generation.\nselect_all_gens : Default \"false\" and parents are not included in the next generation pool for selections. Set select_all_gens to \"true\" if the selections consider individuals from all generations.","category":"page"},{"location":"core/breed/#Outputs","page":"Breed: Wrap-up Function","title":"Outputs","text":"","category":"section"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"By default, two cohort objects will be returned. The first cohort is assumed to be male progenies and the other cohort are female progenies. The size of two cohorts will folow the ratio raiot_malefemale. When ratio_malefemale is set to 0, only one cohort will be returned.","category":"page"},{"location":"core/breed/#Examples","page":"Breed: Wrap-up Function","title":"Examples","text":"","category":"section"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"We can have 10 sires and mate each sire with 5 dams for 5 generations. In each generation, we randomly select 10 male progenies as sires and all female progenies as dams for the next generation. We can derive such breeding scheme as below:","category":"page"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"julia> args  = Dict(# mating arguments\n                    :nA               => 10,\n                    :nB_per_A         => 5,\n                    :n_per_mate       => 2,\n                    :ratio_malefemale => 1.0,\n                    # selection arguments\n                    :is_random        => true,\n                    # breeding arguments\n                    :n_gens           => 5,\n                    :nA_select        => 10,\n                    :select_all_gens  => true)","category":"page"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"Simulate 10 sires and 50 dams as founders.","category":"page"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"julia> sires = Founders(10)\njulia> dams  = Founders(50)","category":"page"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"Breed cohorts based on the defined arguments.","category":"page"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"julia> sires, dams = breed(sires, dams; args...)\n[ Info: Gen 0 -> Mean of BVs: [1.665 2.745], Variance of BVs: [1.008 0.479]\n[ Info: Gen 1 -> Mean of BVs: [1.719 2.715], Variance of BVs: [0.96 0.546]\n[ Info: Gen 2 -> Mean of BVs: [1.754 2.777], Variance of BVs: [0.936 0.724]\n[ Info: Gen 3 -> Mean of BVs: [1.766 2.796], Variance of BVs: [0.927 0.775]\n[ Info: Gen 4 -> Mean of BVs: [1.773 2.771], Variance of BVs: [0.951 0.781]\n[ Info: Gen 5 -> Mean of BVs: [1.813 2.751], Variance of BVs: [0.952 0.804]\n([ Info: Cohort (60 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [1.855 2.593]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.884 0.697]\n, [ Info: Cohort (300 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [1.805 2.782]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.969 0.822]","category":"page"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"The result is equivalent to the following mate-select iterations:","category":"page"},{"location":"core/breed/","page":"Breed: Wrap-up Function","title":"Breed: Wrap-up Function","text":"julia> for _ in 1:5\n            males, females = mate(sires, dams, args...)\n            sires         += select(males, n_sires, args...)\n            dams          += females\n       end","category":"page"},{"location":"core/select/#Selection","page":"Selection","title":"Selection","text":"","category":"section"},{"location":"core/select/","page":"Selection","title":"Selection","text":"Pages = [\"select.md\"]\nDepth = 4","category":"page"},{"location":"core/select/","page":"Selection","title":"Selection","text":"select(cohort      ::Cohort,\n       n           ::Int64,\n       criteria    ::Union{String, Array} = \"phenotypes\";\n       h2          ::Union{Array{Float64}, Float64}=GLOBAL(\"h2\"),\n       ve          ::Union{Array{Float64}, Float64}=GLOBAL(\"Ve\"),\n       weights     ::Array{Float64, 1}  =[1.0],\n       return_log  ::Bool               =false,\n       is_random   ::Bool               =false,\n       silent      ::Bool               =GLOBAL(\"silent\")\n\nselect(cohort::Cohort, ratio::Float64; args...)","category":"page"},{"location":"core/select/#Arguments","page":"Selection","title":"Arguments","text":"","category":"section"},{"location":"core/select/","page":"Selection","title":"Selection","text":"Positional arguments","category":"page"},{"location":"core/select/","page":"Selection","title":"Selection","text":"cohort : A cohort from which individuals are selected.\nn : n individuals are selected.\nratio : ratio portion of individuals are selected.\ncriteria : Criteria that will be used for the selecition. Default \"phenotypes\", the options are [\"phenotypes\", \"GBLUP\", array]. If set to \"GBLUP\",  a genetic evaluation is carried out by JWAS and the estimated breeding values will be the criteria. It's also avaialbe to provdie the criteria (e.g., phenotypes matrix) directly for the selection.","category":"page"},{"location":"core/select/","page":"Selection","title":"Selection","text":"Keyword arguments","category":"page"},{"location":"core/select/","page":"Selection","title":"Selection","text":"h2 : The heritability h2 of the simulated phenotypes.\nve : The residual covariance ve of the simulated phenotypes.\nweight : Linear coefficients of traits for the selection. The selection is more sensitive to traits with greater weight. Negative\nreturn_log : Default false. Set true to return selection differential and selection response besides the selected cohort.\nsilent : Default false. Set true to mute the log messages.","category":"page"},{"location":"core/select/#Outputs","page":"Selection","title":"Outputs","text":"","category":"section"},{"location":"core/select/","page":"Selection","title":"Selection","text":"A selected cohort object will be returned. If return_log is set to true, a dictionary object containing the selected cohort, selection differential, and selection response will be returned.","category":"page"},{"location":"core/select/#Example","page":"Selection","title":"Example","text":"","category":"section"},{"location":"core/select/#Single-Trait-Selection","page":"Selection","title":"Single Trait Selection","text":"","category":"section"},{"location":"core/select/","page":"Selection","title":"Selection","text":"Set demo genome and phenome with single traits controlled by 50 QTLs.","category":"page"},{"location":"core/select/","page":"Selection","title":"Selection","text":"julia> build_demo()\njulia> build_phenome(50)\njulia> summary()\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 10\n[ Info: \n[ Info: Chromosome Length (cM): 1500.0\n[ Info: [150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0]\n[ Info: \n[ Info: Number of Loci        : 1000\n[ Info: [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]\n[ Info: \n[ Info: Genotyping Error      : 0.0\n[ Info: Mutation Rate         : 0.0\n[ Info: \n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 1\n[ Info: Heritability (h2)     : [0.5]\n┌ Info: \n│   Genetic_Variance =\n│    1×1 Array{Float64,2}:\n└     1.0\n┌ Info: \n│   Residual_Variance =\n│    1×1 Array{Float64,2}:\n└     1.0\n[ Info: Number of QTLs        : [50]","category":"page"},{"location":"core/select/","page":"Selection","title":"Selection","text":"Initialize a cohort with 100 individuals","category":"page"},{"location":"core/select/","page":"Selection","title":"Selection","text":"julia> cohort = Cohort(100)","category":"page"},{"location":"core/select/#Select-30-individuals","page":"Selection","title":"Select 30 individuals","text":"","category":"section"},{"location":"core/select/","page":"Selection","title":"Selection","text":"# Select top 30 individuals\njulia> cohort_s = select(cohort, 30)\n# Equivalent\njulia> cohort_s = select(cohort, 0.3)\n\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [1.174]\n[ Info: Selection response     (G): [0.843]\n┌ Info:\n│   Residual_Variance =\n│    1×1 Array{Float64,2}:\n└     1.0\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info:\n[ Info: Mean of breeding values:\n[ Info: [1.448]\n[ Info:\n[ Info: Variance of breeding values:\n[ Info: [0.367]","category":"page"},{"location":"core/select/#Assign-Heritability-h2-or-Residual-Covariance-ve","page":"Selection","title":"Assign Heritability h2 or Residual Covariance ve","text":"","category":"section"},{"location":"core/select/","page":"Selection","title":"Selection","text":"# Assign heritability\njulia> progenies = select(cohort, 30, h2=0.1)\n\n# Equivalent in the case where genetic variance `vg` is 1.0\njulia> progenies = select(cohort, 30, ve=9.0)\n\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [1.182]\n[ Info: Selection response     (G): [0.338]\n┌ Info:\n│   Residual_Variance =\n│    1×1 Array{Float64,2}:\n└     9.0\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [0.956]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.643]","category":"page"},{"location":"core/select/#Negative-Selection","page":"Selection","title":"Negative Selection","text":"","category":"section"},{"location":"core/select/","page":"Selection","title":"Selection","text":"Set is_positive=false to rank individuals in ascending order","category":"page"},{"location":"core/select/","page":"Selection","title":"Selection","text":"julia> progenies = select(cohort, 30, is_positive=false)\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [-1.19]\n[ Info: Selection response     (G): [-0.89]\n┌ Info: \n│   Residual_Variance =\n│    1×1 Array{Float64,2}:\n└     1.0\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [-0.24]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.566]","category":"page"},{"location":"core/select/#Random-Selection","page":"Selection","title":"Random Selection","text":"","category":"section"},{"location":"core/select/","page":"Selection","title":"Selection","text":"julia> progenies = select(cohort, 30, is_random=true)\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [-0.06]\n[ Info: Selection response     (G): [-0.191]\n┌ Info: \n│   Residual_Variance =\n│    1×1 Array{Float64,2}:\n└     1.0\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [0.441]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.946]","category":"page"},{"location":"core/select/#Selection-wiht-Multiple-Parameters","page":"Selection","title":"Selection wiht Multiple Parameters","text":"","category":"section"},{"location":"core/select/","page":"Selection","title":"Selection","text":"It's possible specify multiple parameters described above in one selection. User can either enclose parameters as keyword arguments, or pass them through a dictionary object.","category":"page"},{"location":"core/select/","page":"Selection","title":"Selection","text":"# Keyword args\njulia> progenies = select(cohort, 30, h2=0.3, is_positive=false)\n\n# Equivalent\njulia> args = Dict(:h2=>0.3,\n                   :is_positive=>false)\njulia> progenies = select(cohort, 30; args...)\n\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [-1.086]\n[ Info: Selection response     (G): [-0.486]\n┌ Info: \n│   Residual_Variance =\n│    1×1 Array{Float64,2}:\n└     2.3333333333333335\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [0.154]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.818]","category":"page"},{"location":"core/select/#Multi-Trait-Selection","page":"Selection","title":"Multi-Trait Selection","text":"","category":"section"},{"location":"core/select/","page":"Selection","title":"Selection","text":"Set demo genome and phenome with single traits controlled by 50 QTLs.","category":"page"},{"location":"core/select/","page":"Selection","title":"Selection","text":"julia> build_demo()\njulia> summary()\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 10\n[ Info: \n[ Info: Chromosome Length (cM): 1500.0\n[ Info: [150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0, 150.0]\n[ Info: \n[ Info: Number of Loci        : 1000\n[ Info: [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]\n[ Info: \n[ Info: Genotyping Error      : 0.0\n[ Info: Mutation Rate         : 0.0\n[ Info: \n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 2\n[ Info: Heritability (h2)     : [0.5, 0.5]\n┌ Info: \n│   Genetic_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n[ Info: Number of QTLs        : [3 8]","category":"page"},{"location":"core/select/","page":"Selection","title":"Selection","text":"Initialize a cohort with 100 individuals","category":"page"},{"location":"core/select/","page":"Selection","title":"Selection","text":"julia> cohort = Cohort(100)","category":"page"},{"location":"core/select/#Assign-Heritabilities-for-Multiple-Traits","page":"Selection","title":"Assign Heritabilities for Multiple Traits","text":"","category":"section"},{"location":"core/select/","page":"Selection","title":"Selection","text":"julia> progenies = select(cohort, 30, h2=[0.9, 0.3])\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [0.468 1.028]\n[ Info: Selection response     (G): [0.383 0.636]\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     0.111111  0.0\n└     0.0       2.33333\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [-0.889 0.28]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.947 0.625]","category":"page"},{"location":"core/select/#Assign-Trait-Correlations-via-Residual-Covariance","page":"Selection","title":"Assign Trait Correlations via Residual Covariance","text":"","category":"section"},{"location":"core/select/","page":"Selection","title":"Selection","text":"julia> progenies = select(cohort, 30, ve=[1   0.3\n                                          0.3   1])\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [0.866 0.925]\n[ Info: Selection response     (G): [0.662 0.762]\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.3\n└     0.3  1.0\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [-0.608 0.406]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.549 0.476]","category":"page"},{"location":"core/select/#Derive-Selection-Index-for-Multiple-Traits","page":"Selection","title":"Derive Selection Index for Multiple Traits","text":"","category":"section"},{"location":"core/select/","page":"Selection","title":"Selection","text":"Assigning a vector to the parameter weights to derive a selection index which is a linear combintation of the weights and the phenotypes.  In this example, we demonstrate two traits with the heritability of 0.3 and 0.8, respectively. And we can select traits with more weight on the second trait which is more heritable, and negatively select the first trait.","category":"page"},{"location":"core/select/","page":"Selection","title":"Selection","text":"julia> progenies = select(cohort, 30, h2=[.3, .8], weights=[-0.1, 0.9])\n[ Info: --------- Selection Summary ---------\n[ Info: Select 30 individuals out of 100 individuals\n[ Info: Selection differential (P): [-0.318 1.027]\n[ Info: Selection response     (G): [-0.233 0.869]\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     2.33333  0.0\n└     0.0      0.25\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (30 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [-1.508 0.513]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [1.053 0.458]","category":"page"},{"location":"core/cohort/#Cohort-and-Founders","page":"Cohort and Founders","title":"Cohort and Founders","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"tip: Cohort and Founders\nIn the current version, Cohort works exactly the same as Founders.","category":"page"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"Pages = [\"cohort.md\"]\nDepth = 4","category":"page"},{"location":"core/cohort/#Initialize-by-population-size","page":"Cohort and Founders","title":"Initialize by population size","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"Cohort(n::Int64=0)","category":"page"},{"location":"core/cohort/#Arguments","page":"Cohort and Founders","title":"Arguments","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"n : An integer to assign the population size.","category":"page"},{"location":"core/cohort/#Examples","page":"Cohort and Founders","title":"Examples","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"julia> cohort = Cohort(5)\n[ Info: Cohort (5 individuals)\n[ Info:\n[ Info: Mean of breeding values:\n[ Info: [1.265 1.697]\n[ Info:\n[ Info: Variance of breeding values:\n[ Info: [1.6 1.4]","category":"page"},{"location":"core/cohort/#Initialize-by-genotypes/haplotypes-files","page":"Cohort and Founders","title":"Initialize by genotypes/haplotypes files","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"Cohort(genetic_data ::Union{DataFrame, Array{Int64}}; args...)\nCohort(filename     ::String; args...)","category":"page"},{"location":"core/cohort/#Arguments-2","page":"Cohort and Founders","title":"Arguments","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"genetic_data : A dataframe/2D-array that stores genotypes/haplotypes in the dimension of individuals by markers.\nfilename : A filepath to a file storing genotypes/haplotypes data.\nn : Number of lines to be loaded from the file. The default value is -1 and the entire file will be loaded.\nrandom : By default it's set to true to randomly select n lines (individuals) from the file to generate the cohort.\nalter_maf : It will update MAF based on the provided genotypes if it's set to true (default).","category":"page"},{"location":"core/cohort/#Example-of-the-demo_genotypes.csv-and-demo_haplotypes.csv","page":"Cohort and Founders","title":"Example of the demo_genotypes.csv and demo_haplotypes.csv","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"Both demo files store marker information for 5 individuals and 4 markers. Use DATA(\"demo_genotypes.csv\") to interact with demo files.","category":"page"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"# demo_genotypes.csv\n# rows: individuals, columns: markers\n# Homozygote is coded as 0 and 2, otherwise is coded as 1\n2,0,0,1\n0,0,1,0\n0,1,0,2\n1,1,0,2\n2,0,2,0\n\n# demo_haplotypes.csv\n# rows: individuals, columns: alleles\n# Reference allele is coded as 0, otherwise is coded as 1\n1,1,0,0,0,0,1,0\n0,0,0,0,1,0,0,0\n0,0,0,1,0,0,1,1\n1,0,1,0,0,0,1,1\n1,1,0,0,1,1,0,0","category":"page"},{"location":"core/cohort/#Example","page":"Cohort and Founders","title":"Example","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"# Load entire file\njulia> cohort = Cohort(\"demo_haplotypes.csv\")\njulia> get_genotypes(cohort)\n5×4 Array{Int64,2}:\n 2  0  0  1\n 2  0  2  0\n 0  0  1  0\n 1  1  0  2\n 0  1  0  2\n\n# Randomly load 3 individuals with a dataframe.\njulia> data = DATA(\"demo_haplotypes.csv\", header=false)\njulia> cohort = Cohort(data, random=true, n=3)\njulia> get_genotypes(cohort)\n3×4 Array{Int64,2}:\n 2  0  2  0\n 0  1  0  2\n 1  1  0  2\n\n# Replace marker MAF by the provided file\njulia> cohort = Cohort(\"demo_haplotypes.csv\", alter_maf=true)\n[ Info: MAF has been updated based on provided haplotypes/genotypes\n[ Info: Cohort (5 individuals)\n[ Info:\n[ Info: Mean of breeding values:\n[ Info: [1.418]\n[ Info:\n[ Info: Variance of breeding values:\n[ Info: [2.012]","category":"page"},{"location":"core/cohort/#Properties","page":"Cohort and Founders","title":"Properties","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"All the listed functions can take a keyword argument ID=true to insert individuals' IDs as the first column.","category":"page"},{"location":"core/cohort/#Genotypes","page":"Cohort and Founders","title":"Genotypes","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"Genotype matirx in the dimension of individuals by markers","category":"page"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"julia> get_genotypes(cohort)\n5×4 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}:\n 0  0  1  0\n 2  0  2  0\n 2  0  0  1\n 0  1  0  2\n 1  1  0  2","category":"page"},{"location":"core/cohort/#QTLs","page":"Cohort and Founders","title":"QTLs","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"QTLs matirx in the dimension of individuals by markers","category":"page"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"julia> get_QTLs(cohort)\n5×3 Array{Int64,2}:\n 2  2  0\n 0  0  2\n 0  1  0\n 1  0  2\n 2  0  1","category":"page"},{"location":"core/cohort/#Breeding-values","page":"Cohort and Founders","title":"Breeding values","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"Breeding values in the dimenstion individuals by traits","category":"page"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"julia> get_BVs(cohort)\n5×2 LinearAlgebra.Adjoint{Float64,Array{Float64,2}}:\n 1.26491   0.0\n 3.79473   0.0\n 1.26491   1.21268\n 0.0       1.69775\n 0.632456  1.69775","category":"page"},{"location":"core/cohort/#Pedigree","page":"Cohort and Founders","title":"Pedigree","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"Pedigree matrix, listed columns are in the order of individuals' ID, sire ID, and dam ID.","category":"page"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"julia> get_pedigree(cohort)\n5×3 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}:\n1  0  0\n2  0  0\n3  0  0\n4  0  0\n5  0  0","category":"page"},{"location":"core/cohort/#Minor-Allele-Frequencies-(MAF)","page":"Cohort and Founders","title":"Minor Allele Frequencies (MAF)","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"In the case where we have 3 QTLs out of 4 markers, we want to compare their allel frequencies.","category":"page"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"julia> get_MAF(cohort)\n4-element Array{Float64,1}:\n 0.5\n 0.2\n 0.3\n 0.5","category":"page"},{"location":"core/cohort/#Phenotypes","page":"Cohort and Founders","title":"Phenotypes","text":"","category":"section"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"Simulate cohort phenotypes based on the defined phenome. h2 and ve can be assigned specifically for this one-time simulation.","category":"page"},{"location":"core/cohort/","page":"Cohort and Founders","title":"Cohort and Founders","text":"julia> get_phenotypes(cohort)\n5×1 Array{Float64,2}:\n  1.1126064336992942\n -0.8337021175232547\n -0.363621019381922\n  4.042256656472762\n  1.7828800511223049","category":"page"},{"location":"core/mate/#Mating","page":"Mating","title":"Mating","text":"","category":"section"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"Pages = [\"mate.md\"]\nDepth = 4","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"mate(cohort_A         ::Cohort,\n     cohort_B         ::Cohort;\n     nA               ::Int64=cohort_A.n,\n     nB_per_A         ::Int64=1,\n     n_per_mate       ::Int64=1,\n     replace_A        ::Bool =false,\n     replace_B        ::Bool =false,\n     ratio_malefemale ::Union{Float64, Int64}=0,\n     scheme           ::String =\"none\",\n     args...)\n\nmate(cohort::Cohort; args...) =  mate(cohort, cohort; args...)","category":"page"},{"location":"core/mate/#Arguments","page":"Mating","title":"Arguments","text":"","category":"section"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"Positional arguments","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"cohort_A : A cohort object that is treated as common mating parents.\ncohort_B : A cohort object that is a mating pool from which individuals are sampled to mate with cohort_A.","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"Keyword arguments","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"nA : nA individuals will be sampled from cohort_A and treated as common parents.\nnB_per_A : nB_per_A individuals sampled from cohort_B will mate with each individual from cohort_A.\nn_per_mate : n_per_mate progenies will be reproduced from each pair of mating parent.\nreplace_A : Whether the sampling is replacable in cohort_A.\nreplace_B : Whether the sampling is replacable in cohort_B.\nratio_malefemale : By default, two cohorts which are male and female progenies will be returned. ratio_malefemale defined the progenies ratio of males over females. If ratio_malefemale=0, only one cohort will be returned.\nscheme : Available options are [\"random\", \"diallel cross\", \"selfing\", \"DH\"]. See the examples for more details.","category":"page"},{"location":"core/mate/#Outputs","page":"Mating","title":"Outputs","text":"","category":"section"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"By default, two cohort objects will be returned. The first cohort is assumed to be male progenies and the other cohort are female progenies. The size of two cohorts will folow the ratio raiot_malefemale. When ratio_malefemale is set to 0, only one cohort will be returned.","category":"page"},{"location":"core/mate/#Example","page":"Mating","title":"Example","text":"","category":"section"},{"location":"core/mate/#Random-mating-(Default)","page":"Mating","title":"Random mating (Default)","text":"","category":"section"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"Initialize cohorts","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"julia> cohort_A = Cohort(5)\njulia> cohort_B = Cohort(10)","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"Define mating events","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"julia> args = Dict(:nA               => cohort_A.n,\n                   :nB_per_A         => 1,\n                   :replace_A        => false,\n                   :replace_B        => false,\n                   :n_per_mate       => 1)\njulia> progenies = mate(cohort_A, cohort_B; args...)\n\n# Equivalent\njulia> progenies = mate(cohort_A, cohort_B)\n\n# Equivalent\njulia> progenies = mate(cohort_A, cohort_B; scheme=\"random\")\n\n# Equivalent\njulia> progenies = cohort_A * cohort_B","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"Check the pedigree to see if the mating goes as desired.","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"julia> get_pedigree(progenies)\n5×3 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}:\n 19  1   8\n 16  2   6\n 17  3  10\n 20  4  15\n 18  5  14","category":"page"},{"location":"core/mate/#Diallel-cross","page":"Mating","title":"Diallel cross","text":"","category":"section"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"Initialize cohorts","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"julia> cohort_A = Cohort(2)\njulia> cohort_B = Cohort(5)","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"Define mating events","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"julia> args = Dict(:nA              => sires.n,\n                   :nB_per_A        => dams.n,\n                   :replace_A       => false,\n                   :replace_B       => false,\n                   :n_per_mate      => 1,\n                   :ratio_malefemale=> 1)\njulia> male, female = mate(cohort_A, cohort_B; args...)\n\n# Equivalent\njulia> male, female = mate(cohort_A, cohort_B; scheme=\"diallel cross\")","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"Check the pedigree to see if the mating goes as desired.","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"julia> get_pedigree(male + female)\n10×3 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}:\n 12  2  7\n 10  2  6\n 11  2  4\n 14  1  3\n 15  1  5\n  9  2  5\n 13  1  6\n 17  1  4\n  8  2  3\n 16  1  7","category":"page"},{"location":"core/mate/#Selfing","page":"Mating","title":"Selfing","text":"","category":"section"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"Initialize cohorts","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"julia> parents = Cohort(5)","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"In the selfing scheme, only one cohort is required.","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"julia> args = Dict(:nA          => 3,\n                   :replace_A   => false,\n                   :n_per_mate  => 5,\n                   :scheme      => \"selfing\")\njulia> progenies = mate(parents; args...)","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"Inspect the pedigree to verify the mating behavior","category":"page"},{"location":"core/mate/","page":"Mating","title":"Mating","text":"julia> get_pedigree(progenies)\n15×3 LinearAlgebra.Adjoint{Int64,Array{Int64,2}}:\n  6  4  4\n  7  4  4\n  8  4  4\n  9  4  4\n 10  4  4\n 11  1  1\n 12  1  1\n 13  1  1\n 14  1  1\n 15  1  1\n 16  5  5\n 17  5  5\n 18  5  5\n 19  5  5\n 20  5  5","category":"page"},{"location":"case/NAM/#Nested-Association-Mapping","page":"Nested Association Mapping","title":"Nested Association Mapping","text":"","category":"section"},{"location":"case/NAM/","page":"Nested Association Mapping","title":"Nested Association Mapping","text":"(Image: )","category":"page"},{"location":"case/NAM/","page":"Nested Association Mapping","title":"Nested Association Mapping","text":"Nested association mapping (NAM) design  (Buckler et al. 2009) is useful in plant breeding for its statistical power in detecting QTLs (Scott et al. 2020). Assuming the studied species is an out-cross crop, we initialize founders in the same way as in the previous example. The base population is simulated to have historical LD and in HWE after more than 1000 generations of random mating. Founders of NAM panel are determined by 25 diversity founders and 1 common parent subsetted from the simulated base population.","category":"page"},{"location":"case/NAM/","page":"Nested Association Mapping","title":"Nested Association Mapping","text":"# Build Genome and Phenome\nbuild_genome(\"map.csv\")\nbuild_phenome(\"map.csv\",\n              vg = [ 1 .5; .5  1],\n              h2 = [0.3, 0.7])\n# Initialize a population with 1,500 founders\nfounders = Founders(1500)\n# Let founders random mate with each other\n# for 1,000 generations \nfor _ in 1:1000\n    founders = mate(founders)\nend\n# Drop the size to 100 individuals and\n# continue the random mating for another 15 generations\nfor _ in 1:15\n    founders = mate(founders[1:100])\nend\n# Subset 26 founders to become the base population\ncommon_parents  = founders[1]\ndiverse_parents = founders[2:26]","category":"page"},{"location":"case/NAM/","page":"Nested Association Mapping","title":"Nested Association Mapping","text":"We let each founder mate with the common parent separately to generate 25 families in the generation F_1. Later, in each families, 200 recombinant inbred lines (RILs) are derived with selfing for 6 generations. Overall, we can have a NAM population with 25 families containing 200 RILs each through the following codes:","category":"page"},{"location":"case/NAM/","page":"Nested Association Mapping","title":"Nested Association Mapping","text":"# Cross each diverse parent with the common parent\nF1 = Cohort()\nfor parent in diverse_parents\n    F1 += common_parents * parent\nend\n# Each family produce 200 progenies by selfing\nargs = Dict(# Mating\n            :n_per_mate => 200,\n            :is_selfing => true,\n            # Selection\n            :is_random  => true,\n            # Breed\n            :n_gens     => 6,\n            :n_select   => 200)\nNAM = Cohort()\nfor family in F1\n    NAM += breed(family, args...)\nend","category":"page"},{"location":"case/NAM/#References","page":"Nested Association Mapping","title":"References","text":"","category":"section"},{"location":"case/NAM/","page":"Nested Association Mapping","title":"Nested Association Mapping","text":"Buckler, E. S., J. B. Holland, P. J. Bradbury, C. B. Acharya, P. J. Brown, et al., 2009 The Genetic Architecture of Maize Flow- ering Time. Science 325: 714–718","category":"page"},{"location":"case/NAM/","page":"Nested Association Mapping","title":"Nested Association Mapping","text":"Scott, M. F., O. Ladejobi, S. Amer, A. R. Bentley, J. Biernaskie, et al., 2020 Multi-parent populations in crops: a toolbox integrating genomics and genetic mapping with breeding. Heredity 125: 396–416.","category":"page"},{"location":"core/build_genome/#Build-Genome","page":"Build Genome","title":"Build Genome","text":"","category":"section"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"build_genome() defines the genetic information including numbers of chromosomes and loci, genetic position, physical position, minor allele frequency, mutation rates, and genotyping error rates.","category":"page"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"Pages = [\"build_genome.md\"]\nDepth = 4","category":"page"},{"location":"core/build_genome/#Quick-Start","page":"Build Genome","title":"Quick Start","text":"","category":"section"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"Quick setup by assigning number of markers and chromosomes.","category":"page"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"build_genome(;n_marker ::Int64=-1,\n              n_chr    ::Int64=10,\n              species  ::String=\"none\",\n              args...)","category":"page"},{"location":"core/build_genome/#Arguments","page":"Build Genome","title":"Arguments","text":"","category":"section"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"n_marker : Number of simulated markers for each chromosome\nn_chr: Number of simulated chromosome with length of 100 centimorgan\nspecies : Infer genetic position (Morgan) by pre-load linkage maps, available species are: [\"cattle\", and \"pig\"]","category":"page"},{"location":"core/build_genome/#Examples","page":"Build Genome","title":"Examples","text":"","category":"section"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"julia> build_genome(n_chr    = 2,\n                    n_marker = 10000)\n\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 2\n[ Info:\n[ Info: Chromosome Length (cM): 200.0\n[ Info: [100.0, 100.0]\n[ Info:\n[ Info: Number of Loci        : 20000\n[ Info: [10000, 10000]\n[ Info:\n[ Info: Genotyping Error      : 0.0\n[ Info: Mutation Rate         : 0.0\n[ Info:","category":"page"},{"location":"core/build_genome/#Build-by-a-File-or-a-DataFrame","page":"Build Genome","title":"Build by a File or a DataFrame","text":"","category":"section"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"Define genome by providing a formatted dataframe or a path to the file.","category":"page"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"build_genome(dt      ::DataFrame;\n             species ::String=\"none\",\n             args...)\n\nbuild_genome(filename::String;\n             species ::String=\"none\",\n             args...)","category":"page"},{"location":"core/build_genome/#Arguments-2","page":"Build Genome","title":"Arguments","text":"","category":"section"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"dt : A DataFrame with required columns of chr and cM, or chr and bp if species is provided for the inference.\nfilename : A filepath to the file containing genome information.\nspecies : Adjust genetic position (Morgan) by pre-load linkage maps, available species are: [\"cattle\", and \"pig\"]","category":"page"},{"location":"core/build_genome/#Example-of-the-DataFrame","page":"Build Genome","title":"Example of the DataFrame","text":"","category":"section"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"4×7 DataFrame\n Row │ id      chr    bp       cM       MAF      eff_1    eff_2\n     │ String  Int64  Int64    Float64  Float64  Float64  Float64\n─────┼────────────────────────────────────────────────────────────\n   1 │ snp_1       1  1818249     50.8      0.5      0.1      0.0\n   2 │ snp_2       1  6557697     80.3      0.5      0.0      0.0\n   3 │ snp_3       2  2298800     39.2      0.5      0.2      0.0\n   4 │ snp_4       2  5015698     66.3      0.5      0.0      0.5","category":"page"},{"location":"core/build_genome/#Examples-2","page":"Build Genome","title":"Examples","text":"","category":"section"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"By a filepath","category":"page"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"julia> build_genome(\"path/map.csv\";\n                    rate_mutation=0.005, rate_error=0.01)","category":"page"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"or a dataframe","category":"page"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"julia> using DataFrames\njulia> data = CSV.read(\"path/map.csv\", DataFrame)\njulia> build_genome(data;\n                    rate_mutation=0.005, rate_error=0.01)\n\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 2\n[ Info:\n[ Info: Chromosome Length (cM): 146.6\n[ Info: [80.3, 66.3]\n[ Info:\n[ Info: Number of Loci        : 4\n[ Info: [2, 2]\n[ Info:\n[ Info: Genotyping Error      : 0.01\n[ Info: Mutation Rate         : 0.005\n[ Info:","category":"page"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"Use cattle genome as reference to infer the genetic positions","category":"page"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"julia> build_genome(\"path/map.csv\"; species=\"cattle\")\n\n[ Info: Arias,J.A. et al. (2009) A high density linkage map of the bovine genome. BMC Genetics, 10, 18.\n[ Info: Reference Genome : Btau 4.0\n[ Info: SNP Chip         : Affymetrix GeneChip Bovine Mapping 10K SNP kit\n\n┌ Warning: The provided genetic distances will be replaced with ones infered from preloaded linkage maps\n└ @ XSim ~/Dropbox/projects/XSim/src/objects/global.jl:118\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 2\n[ Info:\n[ Info: Chromosome Length (cM): 16.8\n[ Info: [15.1, 1.7]\n[ Info:\n[ Info: Number of Loci        : 4\n[ Info: [2, 2]\n[ Info:\n[ Info: Genotyping Error      : 0.0\n[ Info: Mutation Rate         : 0.0\n[ Info:\n","category":"page"},{"location":"core/build_genome/#Build-by-Pre-Loaded-Genome","page":"Build Genome","title":"Build by Pre-Loaded Genome","text":"","category":"section"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"Define genome by pre-loaded genome from reference.","category":"page"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"build_genome(;species :: String=\"none\")","category":"page"},{"location":"core/build_genome/#Arguments-3","page":"Build Genome","title":"Arguments","text":"","category":"section"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"species : Adjust genetic position (Morgan) by pre-load linkage maps, available species are: [\"cattle\", and \"pig\"]","category":"page"},{"location":"core/build_genome/#Examples-3","page":"Build Genome","title":"Examples","text":"","category":"section"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"julia> build_genome(species=\"pig\")\n[ Info: Tortereau,F. et al. (2012) A high density recombination map of the pig reveals a correlation between sex-specific recombination and GC content. BMC Genomics, 13, 586.\n[ Info: Reference Genome : Sscrofa 10.2\n[ Info: SNP Chip         : PorcineSNP60 BeadChip\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 18\n[ Info: \n[ Info: Chromosome Length (cM):\n[ Info: [98.0, 94.7, 96.8, 92.2, 89.3, 124.1, 112.8, 94.8, 95.4, 84.4, 64.6, 77.0, 97.6, 106.6, 93.5, 66.5, 53.9, 49.1]\n[ Info: \n[ Info: Number of Loci        : 45292\n[ Info: [6580, 2356, 1938, 3682, 2217, 1766, 3489, 2100, 2538, 1281, 1805, 1072, 3529, 4053, 2612, 1513, 1646, 1115]\n[ Info: \n[ Info: Genotyping Error      : 0.0\n[ Info: Mutation Rate         : 0.0\n[ Info: ","category":"page"},{"location":"core/build_genome/#Build-by-Explicit-Definition","page":"Build Genome","title":"Build by Explicit Definition","text":"","category":"section"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"Define genome by providing genetic information of each loci explicitly.","category":"page"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"build_genome(chromosome    ::Array{Int64,   1},\n             bp            ::Array{Int64,   1},\n             cM            ::Array{Float64, 1},\n             maf           ::Array{Float64, 1};\n             rate_mutation ::Float64=0.0,\n             rate_error    ::Float64=0.0)","category":"page"},{"location":"core/build_genome/#Arguments-4","page":"Build Genome","title":"Arguments","text":"","category":"section"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"chromosome : Chromosome codes\nbp : Physical positions\ncM : Genetic positions\nmaf : Minor allele frequencies\nrate_mutation : Mutation rate\nrate_error : Error rate of genotyping","category":"page"},{"location":"core/build_genome/#Examples-4","page":"Build Genome","title":"Examples","text":"","category":"section"},{"location":"core/build_genome/","page":"Build Genome","title":"Build Genome","text":"julia> ch  = [1,    1,     2,    2,    2]\njulia> bp  = [130,  205,   186,  503,  780]\njulia> cM  = [85.7, 149.1, 37.4, 83.6, 134.3]\njulia> maf = [0.5,  0.5,   0.5,  0.5,  0.5]\njulia> build_genome(ch, bp, cM, maf)\n\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 2\n[ Info:\n[ Info: Chromosome Length (cM): 283.4\n[ Info: [149.1, 134.3]\n[ Info:\n[ Info: Number of Loci        : 5\n[ Info: [2, 3]\n[ Info:\n[ Info: Genotyping Error      : 0.0\n[ Info: Mutation Rate         : 0.0\n[ Info:","category":"page"},{"location":"case/crossbreed/#Rotational-Cross-Breeding","page":"Rotational Cross-Breeding","title":"Rotational Cross-Breeding","text":"","category":"section"},{"location":"case/crossbreed/","page":"Rotational Cross-Breeding","title":"Rotational Cross-Breeding","text":"(Image: )","category":"page"},{"location":"case/crossbreed/","page":"Rotational Cross-Breeding","title":"Rotational Cross-Breeding","text":"At first, a cattle founder population can either be initialized based on real haplotypes or genotypes (described in the section \"generating founders\"), or be simulated from a base popula- tion in linkage and Hardy–Weinberg equilibria through random mating over many generations to generate LD. We start with a population of 1500 individuals. Except for selfing, we let them randomly mate for 1000 discrete generations. In order to expand the LD range, we drop the population size to 100, and have them random matings for another 15 generations. This approach is similar to that proposed in (Habier et al. 2010), which shows the similarity to real dairy cattle (de Roos et al. 2008). By default, the mate() function can have all individuals from the input cohort mating randomly with each other:","category":"page"},{"location":"case/crossbreed/","page":"Rotational Cross-Breeding","title":"Rotational Cross-Breeding","text":"# Build Genome and Phenome\nbuild_genome(\"map.csv\", species = \"cattle\")\nbuild_phenome(\"map.csv\",\n              vg = [ 1 .5; .5  1],\n              h2 = [0.3, 0.7])\n# Initialize a population with 1,500 founders\nfounders = Founders(1500)\n# Let founders random mate with each other\n# for 1,000 generations \nfor _ in 1:1000\n    founders = mate(founders)\nend\n# Drop the size to 100 individuals and\n# continue the random mating for another 15 generations\nfor _ in 1:15\n    founders = mate(founders[1:100])\nend\nsires_base = dams_base = founders","category":"page"},{"location":"case/crossbreed/","page":"Rotational Cross-Breeding","title":"Rotational Cross-Breeding","text":"Secondly, three pure breeds (breed A, B, and C) are generated in generation G_0 from the founder population through random matings for 10 generations. In breed A, 50 sires and 500 dams are randomly selected, and each sire is mated with 10 dams. The ratio of male over female is 1. In both breed B and C, 100 sires and 2000 dams are randomly selected, and each sire is mated with 20 dams. Thus, three pure breeds are simulated, where breed A is a small breed with 50 males and 500 females, and both breed B and C have 100 males and 2000 females.","category":"page"},{"location":"case/crossbreed/","page":"Rotational Cross-Breeding","title":"Rotational Cross-Breeding","text":"#Simulate three pure breeds\nargs_A  = Dict(# Mating\n               :nA               => 10,\n               :nB_per_A         => 2,\n               :ratio_malefemale => 1,\n               # Selection\n               :is_random        => true,\n               # Breeding\n               :n_gens           => 10,\n               :n_select_males   => 50)\nargs_BC = Dict(# Mating\n               :nA              => 20,\n               :nB_per_A        => 2,\n               :ratio_malefemale => 1,\n               # Selection\n               :is_random        => true,\n               # Breeding\n               :n_gens           => 10,\n               :n_select_males   => 100)\n# Breed A, B, and C\nsires_A, dams_A = breed(sires_base, dams_base;  args_A...)\nsires_B, dams_B = breed(sires_base, dams_base;  args_BC...)\nsires_C, dams_C = breed(sires_base, sires_base; args_BC...)","category":"page"},{"location":"case/crossbreed/","page":"Rotational Cross-Breeding","title":"Rotational Cross-Breeding","text":"Thirdly, we sample 100 sires from breed B and 1000 dams from breed C as two mating cohorts. Each sire will mate with 10 dams and leads to 1,000 male and 1,000 female progenies at generation G_1. which will be sires and dams in the next generation G_2. In G_2, we use 50 sires from Breed A and cross them with dams from G_1. And we can generate another 1,000 males and 1,000 females as parents for the next round. In G_3, 100 sires sampled from Breed C will mate with G_2 and produce another 2,000 progenies. The sire sources in the next generation will be back to Breed B and the cycle continues. The described process can be adequately expressed in XSimV2:","category":"page"},{"location":"case/crossbreed/","page":"Rotational Cross-Breeding","title":"Rotational Cross-Breeding","text":"# Rotation parameters\nargs = Dict(:n_pop            => 2000,\n            :n_per_mate       => 2,\n            :ratio_malefemale => 1)\n# Rotation (G1)\nsires_A, dams_A      = mate(sires_A, dams_A)\nsires_B, dams_B      = mate(sires_B, dams_B)\nsires_C, dams_C      = mate(sires_C, dams_C)\nmales_G1, females_G1 = mate(sires_B, dams_C; args...)\n# Rotation (G2)\nsires_A, dams_A      = mate(sires_A, dams_A)\nsires_B, dams_B      = mate(sires_B, dams_B)\nsires_C, dams_C      = mate(sires_C, dams_C)\nmales_G2, females_G2 = mate(sires_A, females_G1; args...)\n# Rotation (G3)\nsires_A, dams_A      = mate(sires_A, dams_A)\nsires_B, dams_B      = mate(sires_B, dams_B)\nsires_C, dams_C      = mate(sires_C, dams_C)\nmales_G3, females_G3 = mate(sires_C, females_G2; args...)","category":"page"},{"location":"case/crossbreed/#References","page":"Rotational Cross-Breeding","title":"References","text":"","category":"section"},{"location":"case/crossbreed/","page":"Rotational Cross-Breeding","title":"Rotational Cross-Breeding","text":"de Roos, A. P. W., B. J. Hayes, R. J. Spelman, and M. E. God- dard, 2008 Linkage Disequilibrium and Persistence of Phase in Holstein–Friesian, Jersey and Angus Cattle. Genetics 179: 1503–1512.","category":"page"},{"location":"case/crossbreed/","page":"Rotational Cross-Breeding","title":"Rotational Cross-Breeding","text":"Habier, D., J. Tetens, F.-R. Seefried, P. Lichtner, and G. Thaller, 2010 The impact of genetic relationship information on ge- nomic breeding values in German Holstein cattle. Genetics Selection Evolution 42: 5.","category":"page"},{"location":"#XSim.jl","page":"Home","title":"XSim.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for XSim.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: New Users\nNew users are strongly encouraged to read the page Demo: Step by Step first.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Efficient CPOS algorithm\nFounders characterized by real genome sequence data\nComplicated pedigree structures among descendants\nStrong extensibilty\nModularism design\nStraightforward interface","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"XSim\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or the beta version","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.add(PackageSpec(name=\"XSim\", rev=\"master\"))","category":"page"},{"location":"#Outline","page":"Home","title":"Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"demo.md\",\n    \"core/build_genome.md\",\n    \"core/build_phenome.md\",\n    \"core/cohort.md,\n    \"core/mate.md,\n    \"core/select.md,\n    \"core/breed.md,\n    \"core/GE.md\",\n    \"case/crossbreed.md\",\n    \"case/NAM.md\",\n    \"lib.md\",\n]\nDepth = 2","category":"page"},{"location":"#Library","page":"Home","title":"Library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib.md\"]","category":"page"},{"location":"#Cite-XSimV2","page":"Home","title":"Cite XSimV2","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@article{cheng_xsim_2015,\n\ttitle = {XSim: Simulation of Descendants from Ancestors with Sequence Data},\n\tvolume = {5},\n\tissn = {2160-1836},\n\tshorttitle = {XSim},\n\turl = {http://g3journal.org/lookup/doi/10.1534/g3.115.016683},\n\tdoi = {10.1534/g3.115.016683},\n\tlanguage = {en},\n\tnumber = {7},\n\tjournal = {G3\\&amp;\\#58; Genes{\\textbar}Genomes{\\textbar}Genetics},\n\tauthor = {Cheng, Hao and Garrick, Dorian and Fernando, Rohan},\n\tmonth = jul,\n\tyear = {2015},\n\tpages = {1415--1417},\n}","category":"page"},{"location":"demo/#Demo:-Step-by-Step","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"","category":"section"},{"location":"demo/#Step-0.-Load-XSim","page":"Demo: Step by Step","title":"Step 0. Load XSim","text":"","category":"section"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"julia> using XSim","category":"page"},{"location":"demo/#Step-1.-Setup-genome-and-phenome","page":"Demo: Step by Step","title":"Step 1. Setup genome and phenome","text":"","category":"section"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"The demo example simulates 10 chromosomes with 100 loci each. And 2 independent traits are controlled by 3 and 8 QTLs, respectively.","category":"page"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"julia> build_genome(n_chr=10, n_marker=100)\n[ Info: --------- Genome Summary ---------\n[ Info: Number of Chromosome  : 10\n[ Info: \n[ Info: Chromosome Length (cM): 1000.0\n[ Info: [100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0]\n[ Info: \n[ Info: Number of Loci        : 1000\n[ Info: [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]\n[ Info: \n[ Info: Genotyping Error      : 0.0\n[ Info: Mutation Rate         : 0.0\n[ Info: \n\njulia> build_phenome([3, 8])\n[ Info: --------- Phenome Summary ---------\n[ Info: Number of Traits      : 2\n[ Info: Heritability (h2)     : [0.5, 0.5]\n┌ Info: \n│   Genetic_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     1.0  0.0\n└     0.0  1.0\n[ Info: Number of QTLs        : [3 8]","category":"page"},{"location":"demo/#Step-2.-Initialize-Founders","page":"Demo: Step by Step","title":"Step 2. Initialize Founders","text":"","category":"section"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"Simulate 3 founder sires","category":"page"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"julia> n_sires = 3\n\njulia> sires   = Founders(n_sires)\n[ Info: Cohort (3 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [2.232 -0.609]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [2.374 0.873]","category":"page"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"Simulate 20 founder dams","category":"page"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"julia> n_dams  = 20\n\njulia> dams    = Founders(n_dams)\n[ Info: Cohort (20 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [2.117 -0.369]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.519 0.732]","category":"page"},{"location":"demo/#Step-3.-Mating","page":"Demo: Step by Step","title":"Step 3. Mating","text":"","category":"section"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"Here, the first cohort in the function mate is cohort_A, and the second one is cohort_B. We let each sire mate with 5 dams, and each mating event will produce 1 male and 1 female progenies when :ratio_malefemale is set to 1.0.","category":"page"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"julia> args_mate = Dict(:nA           => 3,\n                        :nB_per_A     => 5,\n                        :n_per_mate   => 2,\n                        :ratio_malefemale => 1.0)\n\njulia> males, females = mate(sires, dams; args_mate...)\n[ Info: --------- Mating Summary ---------\n[ Info: Generated 30 individuals from 3 cohort_A individuals\n[ Info: Every cohort_A individual mates with 5 individuals from cohort_B\n[ Info: And each mating reproduces 2 progenies\n[ Info: \n[ Info: --------- Offsprings Summary ---------\n([ Info: Cohort (15 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [2.294 -0.592]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.846 0.33]\n, [ Info: Cohort (15 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [1.614 -0.586]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [1.313 0.527]\n)","category":"page"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"Users can check how the mating was performed by calling get_pedigree() function. The first column is individual ID, and the second and the third correspond to the individual's sire and dam, respectively. We can use + to concatenate two cohort.","category":"page"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"julia> progenies = males + females\n\njulia> get_pedigree(progenies)\n30×3 Array{Int64,2}:\n 24  2  22\n 25  2  22\n 26  2   7\n 27  2   7\n 28  2  11\n 29  2  11\n 30  2   6\n 31  2   6\n 32  2  17\n 33  2  17\n 34  1  23\n 35  1  23\n 36  1  19\n 37  1  19\n 38  1   4\n 39  1   4\n 40  1  16\n 41  1  16\n 42  1  13\n 43  1  13\n 44  3  20\n 45  3  20\n 46  3  18\n 47  3  18\n 48  3  12\n 49  3  12\n 50  3   9\n 51  3   9\n 52  3   5\n 53  3   5","category":"page"},{"location":"demo/#Step-4.-Selection","page":"Demo: Step by Step","title":"Step 4. Selection","text":"","category":"section"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"Next, although the heritability is set to 0.5, we can reassign it in :h2 with a new value (or a vector for multiple traits). The argument :weights allows us to weight two traits differently in the selction. This example we select 3 sires from the 15 male progenies and 10 dams from the 15 female progenies.","category":"page"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"julia> args_select = Dict(:h2     => [.8, .5],\n                          :weights=> [.6, .4])\n\njulia> sires       = select(males, 3; args_select...)\n[ Info: --------- Selection Summary ---------\n[ Info: Select 3 individuals out of 15 individuals\n[ Info: Selection differential (P): [0.794 0.972]\n[ Info: Selection response     (G): [0.68 1.078]\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     0.25  0.0\n└     0.0   1.0\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (3 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [2.591 0.597]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.972 0.095]\n\njulia> dams        = select(females, 10; args_select...)\n[ Info: --------- Selection Summary ---------\n[ Info: Select 10 individuals out of 15 individuals\n[ Info: Selection differential (P): [0.328 0.17]\n[ Info: Selection response     (G): [0.37 0.237]\n┌ Info: \n│   Residual_Variance =\n│    2×2 Array{Float64,2}:\n│     0.25  0.0\n└     0.0   1.0\n[ Info: --------- Offsprings Summary ---------\n[ Info: Cohort (10 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [2.883 -0.093]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.56 1.007]","category":"page"},{"location":"demo/#Step-5.-Expand-to-Multiple-Generations","page":"Demo: Step by Step","title":"Step 5. Expand to Multiple Generations","text":"","category":"section"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"We can expand the described mate() and select() to :n_gens generations. By assigning :n_select_males and :n_select_females to specify how many progenies will be passed to the next generation.","category":"page"},{"location":"demo/#Expand-to-multiple-generations","page":"Demo: Step by Step","title":"Expand to multiple generations","text":"","category":"section"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"julia> args_breed  = Dict(:n_gens           => 5,\n                          :n_select_males   => 3,\n                          :n_select_females => 20)\n\njulia> sires, dams = breed(sires, dams; args_breed..., args_mate..., args_select...)\n[ Info: Gen 0 -> Mean of BVs: [2.816 0.066], Variance of BVs: [0.598 0.863]\n[ Info: Gen 1 -> Mean of BVs: [3.063 0.429], Variance of BVs: [0.998 1.014]\n[ Info: Gen 2 -> Mean of BVs: [3.596 0.483], Variance of BVs: [0.481 0.524]\n[ Info: Gen 3 -> Mean of BVs: [4.001 0.84], Variance of BVs: [0.138 0.574]\n[ Info: Gen 4 -> Mean of BVs: [4.18 0.965], Variance of BVs: [0.065 0.807]\n[ Info: Gen 5 -> Mean of BVs: [4.18 1.182], Variance of BVs: [0.065 0.515]\n([ Info: Cohort (3 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [4.192 1.523]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.03 0.83]\n, [ Info: Cohort (15 individuals)\n[ Info: \n[ Info: Mean of breeding values: \n[ Info: [4.177 1.114]\n[ Info: \n[ Info: Variance of breeding values: \n[ Info: [0.074 0.477]","category":"page"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"julia> summary(sires + dams)\nDict{String,Any} with 3 entries:\n  \"mu_g\"  => [4.18 1.182]\n  \"var_g\" => [0.065 0.515]\n  \"n\"     => 18","category":"page"},{"location":"demo/#Modularism","page":"Demo: Step by Step","title":"Modularism","text":"","category":"section"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"Codes below are equivalent to the breed() function","category":"page"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"julia>  for i in 1:5\n            males, females = mate(sires, dams; args_mate...)\n            sires          = select(males, 3; args_select...)\n            dams           = select(females, 20; args_select...)\n        end\n","category":"page"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"julia> summary(sires + dams)\nDict{String,Any} with 3 entries:\n  \"mu_g\"  => [4.259 2.05]\n  \"var_g\" => [0.024 0.454]\n  \"n\"     => 18","category":"page"},{"location":"demo/#Complete-Codes","page":"Demo: Step by Step","title":"Complete Codes","text":"","category":"section"},{"location":"demo/","page":"Demo: Step by Step","title":"Demo: Step by Step","text":"# Load XSim\nusing XSim\nimport Random\nRandom.seed!(95616)\n\n# Build genome and phenome\nbuild_genome(n_chr=10, n_marker=100)\nbuild_phenome([3, 8])\n\n# Initialize founders\nn_sires = 3\nn_dams  = 20\nsires   = Founders(n_sires)\ndams    = Founders(n_dams)\n\n# Define parameters\nargs     = Dict(# mating\n                :nA               => 3,\n                :nB_per_A         => 5,\n                :n_per_mate       => 2,\n                :ratio_malefemale => 1.0,\n                # selection\n                :h2               => [.8, .5],\n                :weights          => [.6, .4],\n                # breeding\n                :n_gens           => 5,\n                :n_select_males   => 3,\n                :n_select_females => 20)\n\n# Breeding program\nsires, dams   = breed(sires, dams; args...)","category":"page"},{"location":"dev/expand_genome/#Expand-Genome-Information","page":"Expand Genome Information","title":"Expand Genome Information","text":"","category":"section"}]
}
